<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OSAKANA</title>
  
  <subtitle>一緒に夢を見よう</subtitle>
  <link href="https://osakana373.github.io/atom.xml" rel="self"/>
  
  <link href="https://osakana373.github.io/"/>
  <updated>2023-10-17T03:32:59.419Z</updated>
  <id>https://osakana373.github.io/</id>
  
  <author>
    <name>おうじせん</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>french-grammar-21-24</title>
    <link href="https://osakana373.github.io/French/grammar/french-grammar-21-24/french-grammar-21-24/"/>
    <id>https://osakana373.github.io/French/grammar/french-grammar-21-24/french-grammar-21-24/</id>
    <published>2023-10-17T03:29:39.000Z</published>
    <updated>2023-10-17T03:32:59.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leçon-vingt-trois"><a class="anchor" href="#leçon-vingt-trois">#</a> LEÇON VINGT-TROIS</h1><h2 id="部分冠词"><a class="anchor" href="#部分冠词">#</a> 部分冠词</h2><ol><li>词形：部分冠词是由表示部分意义的介词 de 加上定冠词 le,la,les 构成</li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">阳性</th><th style="text-align:center">阴性</th></tr></thead><tbody><tr><td style="text-align:center">单数</td><td style="text-align:center">du(de l')</td><td style="text-align:center">de la(de l')</td></tr><tr><td style="text-align:center">复数</td><td style="text-align:center">des</td><td style="text-align:center">des</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leçon-vingt-trois&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#leçon-vingt-trois&quot;&gt;#&lt;/a&gt; LEÇON VINGT-TROIS&lt;/h1&gt;
&lt;h2 id=&quot;部分冠词&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#部</summary>
      
    
    
    
    <category term="法语" scheme="https://osakana373.github.io/categories/French/"/>
    
    <category term="法语语法" scheme="https://osakana373.github.io/categories/French/grammar/"/>
    
    
    <category term="法语" scheme="https://osakana373.github.io/tags/%E6%B3%95%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>french-grammar-17-20</title>
    <link href="https://osakana373.github.io/French/grammar/french-grammar-17-20/french-grammar-17-20/"/>
    <id>https://osakana373.github.io/French/grammar/french-grammar-17-20/french-grammar-17-20/</id>
    <published>2023-10-17T01:26:52.000Z</published>
    <updated>2023-10-17T03:36:22.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leçon-dix-sept"><a class="anchor" href="#leçon-dix-sept">#</a> LEÇON DIX-SEPT</h1><h2 id="间接宾语人称代词"><a class="anchor" href="#间接宾语人称代词">#</a> 间接宾语人称代词</h2><table><thead><tr><th style="text-align:center">me(m')</th><th style="text-align:center">我</th><th style="text-align:center">nous</th><th style="text-align:center">我们</th></tr></thead><tbody><tr><td style="text-align:center">te(t')</td><td style="text-align:center">你</td><td style="text-align:center">vous</td><td style="text-align:center">您，你们</td></tr><tr><td style="text-align:center">lui</td><td style="text-align:center">他，她，它</td><td style="text-align:center">leur</td><td style="text-align:center">他 (她、它) 们</td></tr></tbody></table><p>用法：代替以介词 à 引导的指人的名词或代词，放在有关动词前<br> + Il présente son ami à ses collègues.<br>+ Il leur présente son ami.<br>+ 他把自己的朋友介绍给同事</p><p>命令式中作间接宾语的人称代词：</p><ol><li>肯定命令式中，作间接宾语的人称代词放动词后面，me 改为 moi，其他不变<ul><li>Donnez-moi ce roman! 给我这本小说！</li></ul></li><li>否定命令式中，放在动词前<ul><li>Ne lui parle pas de ça! 别和他讲这事！</li></ul></li></ol><p>说明：</p><ol><li>直接 / 间接宾语人称代词在句中位置一样</li><li>在直接宾语人称代词中，第三人称单数有阴阳性的区别：le,la；间接宾语人称代词无阴阳性区别，都用 lui</li></ol><h2 id="最近过去时"><a class="anchor" href="#最近过去时">#</a> 最近过去时</h2><p>表示刚刚发生或完成的动作，由 venir de + 原形动词构成，这里 venir 失去 “来” 的意思，仅起助动词作用<br> + Il vient de rentrer. 他刚回来</p><h2 id="代词en的用法"><a class="anchor" href="#代词en的用法">#</a> 代词 en 的用法</h2><p>基本概念是代替 “de + 名词”，可指人或物，一般放在动词前面</p><ol><li>代替 “不定冠词 + 名词”，作直接宾语：<ul><li>Est-ce que vous avez des frères?</li><li>Oui, j'en ai.</li><li>Non, je n'en ai pas. (en = des frères)</li></ul></li><li>代替 “de + 名词”，作形容词补语：<ul><li>Est-il content de son travail?</li><li>Oui, il en est content. (en = de son travail)</li></ul></li><li>代替由数词限定的名词或代替 “de + 名词”，作数词或数量副词的补语：<ul><li>Vous avez beaucoup d'amis, n'est-ce pas?</li><li>Oui, j'en ai beaucoup. (=J'ai beaucoup d'amis)</li></ul></li><li>代替 de 引导的间接宾语（只指物）<ul><li>Il parle de son pays. 他谈自己的家乡</li><li>Il enparle.</li></ul></li><li>代替介词 de 引导的地点状语<ul><li>Vous venez de Chine?</li><li>Oui, j'en viens.</li></ul></li><li>代替介词 de 引导的间接宾语（只指物）<ul><li>Achète-moi un dictionnaire de français, j'en ai besoin.</li></ul></li></ol><p>注意：若间接宾语指人，则不能用 en 代替，须用重读人称代词代替<br> + Il parle souvent de lui (= son frère).</p><h1 id="leçon-dix-huit"><a class="anchor" href="#leçon-dix-huit">#</a> LEÇON DIX-HUIT</h1><h2 id="无人称代词"><a class="anchor" href="#无人称代词">#</a> 无人称代词</h2><p>只有原形动词和第三人称单数形式，主语使用 il</p><ol><li>Il y a... 有</li><li>il est... 表示时间</li><li>il fait... 表示天气<ul><li>Il fait beau/mauvais/du vent 天气好 / 不好 / 刮风</li></ul></li><li>il faut... 应该...，要...</li><li>无人称代词 pleuvoir 和 neiger<ul><li>Il pleut toujours. 总在下雨</li><li>Il ne neige pas dans cette région. 这个地区不下雪</li></ul></li></ol><h2 id="年-季-月-日-星期表达法"><a class="anchor" href="#年-季-月-日-星期表达法">#</a> 年、季、月、日、星期表达法</h2><h3 id="年anannée"><a class="anchor" href="#年anannée">#</a> 年（an,année）</h3><p>表示 “在... 年时 “，加介词 en<br>+ En quelle année sommes-nous? 今年是哪一年？<br>+ Nous sommes en 1988.</p><h3 id="季la-saison"><a class="anchor" href="#季la-saison">#</a> 季（la saison）</h3><p>除 printemps 使用 au 外，其他季节用介词 en</p><p>au printemps, en hiver, en automne, en été</p><ul><li>En quelle saison sommes-nous? 现在是什么季节？</li><li>Nous sommes au printemps. 现在是春天</li></ul><h3 id="月"><a class="anchor" href="#月">#</a> 月</h3><p>表示 “月份” 可使用 “en + 月份” 或 “au mois de + 月份”：<br>+ En quel mois sommes-nous? 现在时几月？<br>+ Nous sommes au mois de septembre. 现在是九月</p><p>或者用：<br>+ Quel mois sommes-nous? 现在是几月？</p><h3 id="日"><a class="anchor" href="#日">#</a> 日</h3><p>表示 “日期” 用定冠词 le：le 16 décembre 十二月十六日</p><ul><li>Quelle date est-ce aujourd'hui? 今天是几号？</li><li>Aujourd'hui, c'est le 7. 今天是 7 号</li></ul><p>或者用：</p><ul><li>Le combien sommes-nous? 今天是几号？</li><li>Nous sommes le 16 avril. 今天是 4 月 15 号</li></ul><h3 id="星期la-semaine"><a class="anchor" href="#星期la-semaine">#</a> 星期（la semaine）</h3><p>表示 “星期几” 时，不加介词或冠词：<br>+ Quel jour est-ce auhourd'hui? 今天是星期几？<br>+ 或 Quel jour de la semaine sommes-nous?<br>+ Nous sommes samedi.</p><p>注意：星期的每一天前加定冠词，表示 “每周几”<br>+ Nous n'avons pas de cours le mercredi. 我们每周三没课</p><h2 id="星期-月份缩写"><a class="anchor" href="#星期-月份缩写">#</a> 星期、月份缩写</h2><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">缩写</th><th style="text-align:center">释义</th></tr></thead><tbody><tr><td style="text-align:center">janvier</td><td style="text-align:center">janv.</td><td style="text-align:center">一月</td></tr><tr><td style="text-align:center">février</td><td style="text-align:center">févr.</td><td style="text-align:center">二月</td></tr><tr><td style="text-align:center">mars</td><td style="text-align:center">mars</td><td style="text-align:center">三月</td></tr><tr><td style="text-align:center">avril</td><td style="text-align:center">avr.</td><td style="text-align:center">四月</td></tr><tr><td style="text-align:center">mai</td><td style="text-align:center">mai</td><td style="text-align:center">五月</td></tr><tr><td style="text-align:center">juin</td><td style="text-align:center">juin</td><td style="text-align:center">六月</td></tr><tr><td style="text-align:center">juillet</td><td style="text-align:center">juil.</td><td style="text-align:center">七月</td></tr><tr><td style="text-align:center">août</td><td style="text-align:center">août</td><td style="text-align:center">八月</td></tr><tr><td style="text-align:center">septembre</td><td style="text-align:center">sept.</td><td style="text-align:center">九月</td></tr><tr><td style="text-align:center">octobre</td><td style="text-align:center">oct.</td><td style="text-align:center">十月</td></tr><tr><td style="text-align:center">novembre</td><td style="text-align:center">nov.</td><td style="text-align:center">十一月</td></tr><tr><td style="text-align:center">décembre</td><td style="text-align:center">déc.</td><td style="text-align:center">十二月</td></tr><tr><td style="text-align:center">lundi</td><td style="text-align:center">lun.</td><td style="text-align:center">星期一</td></tr><tr><td style="text-align:center">mardi</td><td style="text-align:center">mar.</td><td style="text-align:center">星期二</td></tr><tr><td style="text-align:center">mercredi</td><td style="text-align:center">mer.</td><td style="text-align:center">星期三</td></tr><tr><td style="text-align:center">jeudi</td><td style="text-align:center">jeu.</td><td style="text-align:center">星期四</td></tr><tr><td style="text-align:center">vendredi</td><td style="text-align:center">ven.</td><td style="text-align:center">星期五</td></tr><tr><td style="text-align:center">samedi</td><td style="text-align:center">sam.</td><td style="text-align:center">星期六</td></tr><tr><td style="text-align:center">dimanche</td><td style="text-align:center">dim.</td><td style="text-align:center">星期日</td></tr></tbody></table><h1 id="leçon-dix-neuf"><a class="anchor" href="#leçon-dix-neuf">#</a> LEÇON DIX-NEUF</h1><h2 id="ouinonsi的用法"><a class="anchor" href="#ouinonsi的用法">#</a> oui,non,si 的用法</h2><ol><li>oui 对肯定疑问句作肯定回答</li><li>si 对否定疑问句作肯定回答（答语本身是肯定的）</li><li>non 表否定</li></ol><h2 id="否定短语"><a class="anchor" href="#否定短语">#</a> 否定短语</h2><ol><li>ne...pas 用于一般否定，表示 “没有”“不”</li><li>ne...plus 表示 “不再...“</li><li>ne...rien 表示 “什么也不...“” 没有任何东西 “（指物）</li><li>ne...jamais 表示 “从来没有”“永远不”<ul><li>Il n'est jamais en retard.</li></ul></li></ol><h2 id="限定短语neque"><a class="anchor" href="#限定短语neque">#</a> 限定短语 ne...que</h2><p>表示 “只是...“” 仅仅...“，ne 放在变位动词前，que 放在所要限定的句子成分前<br> + Je n'ai que deux valises. 我只有两只行李箱</p><h2 id="连词que引导的从句"><a class="anchor" href="#连词que引导的从句">#</a> 连词 que 引导的从句</h2><p>有些动词后可接以连词 que 引导的从句，该从句作主句动词的直接宾语，这类动词有 dire（说，讲），croire（相信，认为），penser（想，思考），comprendre（包含，明白，懂得），savoir（会，懂得，知道），voir（看见，会见），espérer（希望，期望）<br>+ Il dit que Paul est malade. 他说保尔病了</p><p>注意： que 相当于 that，不可省略</p><h1 id="leçon-vingt"><a class="anchor" href="#leçon-vingt">#</a> LEÇON VINGT</h1><h2 id="过去分词"><a class="anchor" href="#过去分词">#</a> 过去分词</h2><p>可与助动词（être, avoir）结合在一起，构成法语的复合时态，构成如下：</p><ol><li>第一组动词：词根加 é<ul><li>parler - parlé</li><li>habiter - habité</li></ul></li><li>第二组动词：词根加 i<ul><li>finir - fini</li><li>réussir - réussi</li></ul></li><li>第三组动词变化不规则，需逐个记忆</li></ol><table><thead><tr><th style="text-align:center">原形</th><th style="text-align:center">过去分词</th><th style="text-align:center">原形</th><th style="text-align:center">过去分词</th></tr></thead><tbody><tr><td style="text-align:center">aller</td><td style="text-align:center">allé</td><td style="text-align:center">mettre</td><td style="text-align:center">mis</td></tr><tr><td style="text-align:center">apprendre</td><td style="text-align:center">appris</td><td style="text-align:center">partir</td><td style="text-align:center">parti</td></tr><tr><td style="text-align:center">attendre</td><td style="text-align:center">attendu</td><td style="text-align:center">pleuvoir</td><td style="text-align:center">plu</td></tr><tr><td style="text-align:center">avoir</td><td style="text-align:center">eu</td><td style="text-align:center">pouvoir</td><td style="text-align:center">pu</td></tr><tr><td style="text-align:center">comprendre</td><td style="text-align:center">compris</td><td style="text-align:center">prendre</td><td style="text-align:center">pris</td></tr><tr><td style="text-align:center">devoir</td><td style="text-align:center">dû</td><td style="text-align:center">recevoir</td><td style="text-align:center">reçu</td></tr><tr><td style="text-align:center">dire</td><td style="text-align:center">dit</td><td style="text-align:center">savoir</td><td style="text-align:center">su</td></tr><tr><td style="text-align:center">écrire</td><td style="text-align:center">écrit</td><td style="text-align:center">sortir</td><td style="text-align:center">sorti</td></tr><tr><td style="text-align:center">être</td><td style="text-align:center">été</td><td style="text-align:center">suivre</td><td style="text-align:center">suivi</td></tr><tr><td style="text-align:center">faire</td><td style="text-align:center">fait</td><td style="text-align:center">venir</td><td style="text-align:center">venu</td></tr><tr><td style="text-align:center">falloir</td><td style="text-align:center">fallu</td><td style="text-align:center">voir</td><td style="text-align:center">vu</td></tr><tr><td style="text-align:center">lire</td><td style="text-align:center">lu</td><td style="text-align:center">vouloir</td><td style="text-align:center">voulu</td></tr></tbody></table><h2 id="复合过去时"><a class="anchor" href="#复合过去时">#</a> 复合过去时</h2><p>表示过去发生的动作，或从现在角度看，已经完成的动作。由 avoir 或 être 的现在时 + 过去分词构成（相当于英语的现在完成时或一般过去时）</p><h3 id="以avoir为助动词的复合过去时"><a class="anchor" href="#以avoir为助动词的复合过去时">#</a> 以 avoir 为助动词的复合过去时</h3><p>所有的及物动词以及大部分的不及物动词在构成复合时态时，均使用助动词 avoir + 过去分词。这里 avoir 已失去本来意义，只作为语法存在<br> + J'ai lu ce livre. / Je n'ai pas lu ce livre.<br>+ Tu as vu Clara et Monique? / As-tu vu ... ?<br>+ J'ai rien vu.</p><ol><li>复合过去时的否定形式，ne...pas 放在助动词两边</li><li>倒装疑问句，助动词 avoir/être 放在主语之前</li><li>très,bien,beaucoup,toujours 之类的副词，及 rien 这样的代词，一般放在助动词和过去分词之间</li></ol><h3 id="以être作助动词的复合过去时"><a class="anchor" href="#以être作助动词的复合过去时">#</a> 以 être 作助动词的复合过去时</h3><p>一小部分位移的不及物动词和所有代词式动词，以 être 作助动词，构成复合过去时</p><p>这部分不及物动词有 aller,apparaître,arriver,descendre,devenir,entrer,monter,mourir,naître,partir,passer,rester,retourner,sortir,tomber,venir,rentrer</p><ol><li>有些动词在作及物动词使用时，用 avoir；作不及物动词时，用 être<ul><li>J'ai monté les valises dans le train.（及物）我把旅行箱搬上火车</li><li>Je suis monté dans le train.（不及物）我上了火车</li></ul></li><li>以 être 作助动词的复合时态中，过去分词有性、数变化，应和主语的性、数一致。过去分词变阴性，一般词末加 e，变复数，词末加 s<ul><li>Hier, Marie est allée à la campagne.</li></ul></li><li>代词式动词过去分词的性、数配合要注意：<ul><li>若自反代词是直接宾语，表示自反意义或相互意义，过去分词必须和自反代词的性、数相配合：<ul><li>Nous nous sommes regardés sans dire un mot.</li><li>我们相互看了看，一声没吭（nous 是直接宾语，相互意义）</li><li>Elles se sont lavées à l'eau chaude.</li><li>她们用热水洗了澡（se 是直接宾语，自反意义）</li></ul></li><li>若自反代词是间接宾语，过去分词无性、数变化：<ul><li>Elle s'est lavé les mains.</li><li>她洗了手（直接宾语 les mains，se 作间接宾语）</li><li>Nous nous sommes parlé en français.</li><li>我们用法语交谈</li></ul></li></ul></li></ol><h3 id="复合时态中的直接宾语和间接宾语人称代词"><a class="anchor" href="#复合时态中的直接宾语和间接宾语人称代词">#</a> 复合时态中的直接宾语和间接宾语人称代词</h3><ol><li>在复合时态中，作直接宾语和间接宾语的人称代词放在助动词前<ul><li>Tu as téléphoné à Pierre?</li><li>Oui, je lui ai téléphoné.</li></ul></li><li>以 avoir 作助动词的复合时态，若直接宾语在动词前，过去分词的性、数要与直接宾语的性、数一致<ul><li>Elle a écrit des lettres.</li><li>Ces lettres elle les a écrites.</li><li>此规则要满足三个前提：<ol><li>以 avoir 作助动词</li><li>直接宾语</li><li>直接宾语在动词前（en 提前，不配合）</li></ol></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leçon-dix-sept&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#leçon-dix-sept&quot;&gt;#&lt;/a&gt; LEÇON DIX-SEPT&lt;/h1&gt;
&lt;h2 id=&quot;间接宾语人称代词&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#间接宾语人称</summary>
      
    
    
    
    <category term="法语" scheme="https://osakana373.github.io/categories/French/"/>
    
    <category term="法语语法" scheme="https://osakana373.github.io/categories/French/grammar/"/>
    
    
    <category term="法语" scheme="https://osakana373.github.io/tags/%E6%B3%95%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>french-grammar-13-16</title>
    <link href="https://osakana373.github.io/French/grammar/french-grammar-13-16/french-grammar-13-16/"/>
    <id>https://osakana373.github.io/French/grammar/french-grammar-13-16/french-grammar-13-16/</id>
    <published>2023-10-12T07:07:42.000Z</published>
    <updated>2023-10-17T01:26:17.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leçon-treize"><a class="anchor" href="#leçon-treize">#</a> LEÇON TREIZE</h1><h2 id="缩合冠词"><a class="anchor" href="#缩合冠词">#</a> 缩合冠词</h2><ol><li><p>介词 de 与定冠词 le,les 连用时，要分别缩合为 du,des 的形式</p><ul><li>de + le = du</li><li>de + les = des</li><li>le bureau du directeur</li><li>les revues des professeurs<br>du 和 des 相当于英语中的 of the</li></ul></li><li><p>介词 à 和定冠词 le,les 连用时，分别缩合为 au,aux 的形式</p><ul><li>à + le = au</li><li>à + les = aux</li><li>M.Duval habite au 3 étage</li><li>Ils vont aux Etats-Unis</li></ul></li></ol><h2 id="代词-y"><a class="anchor" href="#代词-y">#</a> 代词 y</h2><p>代词 y 代替以 à,dans 等介词引导的地点状语，表示‘这儿’‘那儿’，放在有关的动词前</p><ul><li>Vous allez à Paris?</li><li>--Oui, j'y vais</li><li>==Non, je n'y vais pas</li></ul><h2 id="国名与所用介词"><a class="anchor" href="#国名与所用介词">#</a> 国名与所用介词</h2><ol><li>法语中国名有阴阳之分，个别国名用复数</li><li>阴性国名和以元音字母开始的阳性国名作地点状语时，用介词 en（去）或 de（来）引导，不用冠词<ul><li>Je vais en France</li><li>Je viens de France</li></ul></li><li>以辅音字母开始的阳性国名保留冠词，用 au 或 du<ul><li>Je vais au Japon</li><li>Je viens du Mexique</li></ul></li><li>复数国名前用 aux 或 des<ul><li>Je vais aux États-Unis</li><li>Je viens des États-Unis</li></ul></li></ol><h1 id="leçon-quatorze"><a class="anchor" href="#leçon-quatorze">#</a> LEÇON QUATORZE</h1><h2 id="命令式"><a class="anchor" href="#命令式">#</a> 命令式</h2><p>只有第二人称单数、复数和第一人称复数三种形式，把直陈式现在时的主语去掉，构成命令式：</p><table><thead><tr><th style="text-align:center">直陈式现在时</th><th style="text-align:center">命令式肯定式</th><th style="text-align:center">命令式否定式</th></tr></thead><tbody><tr><td style="text-align:center">tu parles</td><td style="text-align:center">parle</td><td style="text-align:center">ne parle pas</td></tr><tr><td style="text-align:center">nous parlons</td><td style="text-align:center">parlons</td><td style="text-align:center">ne parlons pas</td></tr><tr><td style="text-align:center">vous parlez</td><td style="text-align:center">parlez</td><td style="text-align:center">ne parlez pas</td></tr></tbody></table><p>注意：</p><ol><li>第一组动词第二人称单数的命令式词尾没有 s</li><li>être 和 avoir 的命令式是特殊的<ul><li>être: sois, soyons, soyez</li><li>avoir: aie, ayons, ayes</li></ul></li></ol><h2 id="最近将来时"><a class="anchor" href="#最近将来时">#</a> 最近将来时</h2><p>由动词 aller 的直陈式现在时加上动词的不定式（原形）构成，表示即将发生的动作</p><ul><li>Nous allons faire ces exercices</li></ul><h2 id="钟点表达法"><a class="anchor" href="#钟点表达法">#</a> 钟点表达法</h2><ol><li>表示钟点，用 il est...</li><li>表示‘半’：<ul><li>une demi-heure 半小时</li><li>Il est midi et demi 中午十二点半</li></ul></li><li>表示‘刻’：<ul><li>Il est sept heures trois quarts. 七点三刻</li><li>Il est minuit et quart. 夜间十二点一刻</li></ul></li><li>表示‘分’：<ul><li>Il est une heure vingt-cinq. 一点二十五分</li></ul></li><li>表示‘差’：<ul><li>Il est onze heures moins le quart. 十一点差一刻</li></ul></li><li>早下晚<ul><li>du matin 早上</li><li>de l'après-midi 下午</li><li>du soir 晚上</li></ul></li></ol><p>注意：</p><ul><li>表示‘过一刻’用 et quart，不加冠词</li><li>表示‘差一刻’用 moins le quart，加冠词</li></ul><h1 id="leçon-quinze"><a class="anchor" href="#leçon-quinze">#</a> LEÇON QUINZE</h1><h2 id="直接宾语人称代词"><a class="anchor" href="#直接宾语人称代词">#</a> 直接宾语人称代词</h2><table><thead><tr><th style="text-align:center">me</th><th style="text-align:center">我</th><th style="text-align:center">nous</th><th style="text-align:center">我们</th></tr></thead><tbody><tr><td style="text-align:center">te</td><td style="text-align:center">你</td><td style="text-align:center">vous</td><td style="text-align:center">你们</td></tr><tr><td style="text-align:center">le</td><td style="text-align:center">他（它）</td><td style="text-align:center">les</td><td style="text-align:center">他们、她们、它们</td></tr><tr><td style="text-align:center">la</td><td style="text-align:center">她（它）</td><td style="text-align:center"></td></tr></tbody></table><ol><li>作直接宾语的人称代词放在变位动词前，在否定句中放在 ne 之后，动词之前<ul><li>Il nous regarde. 他看着我们</li><li>Il ne m'écoute pas. 他不听我的</li></ul></li><li>在助动词 + 原形动词的句式中（如最近将来时，以及 pouvoir, devoir, vouloir 加原形动词），作直接宾语的人称代词要放在原形动词前<ul><li>Vous pouvez me suivre. 您可以跟我来</li></ul></li><li>me, te, le, la 在以元音字母或哑音 h 开始的动词前要省音，变成 m',t',l',l'<ul><li>Elle m'écoute. 她听我的</li></ul></li><li>命令式中作直接宾语的人称代词<ol><li>肯定，放在动词之后，me,te 变 moi,toi, 其他不变<ul><li>Excusez-moi! 请原谅我！</li><li>Prends-le. 拿去</li></ul></li><li>否定，放在动词前<ul><li>Ne me regarde pas. 别看我</li></ul></li></ol></li></ol><h2 id="泛指人称代词-on"><a class="anchor" href="#泛指人称代词-on">#</a> 泛指人称代词 on</h2><p>泛指人称代词在句中作主语，动词使用第三人称单数形式</p><ol><li>指某人<ul><li>On frappe à la porte. 有人敲门</li></ul></li><li>指任何人<ul><li>On ne réussit pas à un examen, si on ne travaille pas assez.</li></ul></li><li>代替其他人称代词（主要代替 nous）<ul><li>On ne me répond pas. (on = ils) 他们不回答我</li></ul></li></ol><h2 id="第二组动词的直陈式现在时"><a class="anchor" href="#第二组动词的直陈式现在时">#</a> 第二组动词的直陈式现在时</h2><p>以 ir 结尾：</p><table><thead><tr><th style="text-align:center">je...is</th><th style="text-align:center">nous...issons</th></tr></thead><tbody><tr><td style="text-align:center">tu...is</td><td style="text-align:center">vous...issez</td></tr><tr><td style="text-align:center">il、elle...it</td><td style="text-align:center">ils、elles...issent</td></tr></tbody></table><h1 id="leçon-seize"><a class="anchor" href="#leçon-seize">#</a> LEÇON SEIZE</h1><h1 id="代词式动词"><a class="anchor" href="#代词式动词">#</a> 代词式动词</h1><p>与自反代词（me,te,se,nous,vous,se）一起使用的动词叫代词式动词。自反代词的人称应与主语一致</p><table><thead><tr><th style="text-align:center">se laver (洗)</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">je me lave</td><td style="text-align:center">nous nous lavons</td></tr><tr><td style="text-align:center">tu te laves</td><td style="text-align:center">vous vous lavez</td></tr><tr><td style="text-align:center">il se lave</td><td style="text-align:center">ils se lavent</td></tr><tr><td style="text-align:center">elle se lave</td><td style="text-align:center">elles se lavent</td></tr></tbody></table><p>代词式动词有两种意义：</p><ol><li>自反意义：动作作用于主语本身（自反代词可当直接 / 间接宾语）<ul><li>Je me lave. 我洗澡 （直接宾语）</li><li>Elle se lave les mains. 她洗手 （les mains 是 laver 的直接宾语，se 是间接宾语）</li></ul></li><li>相互意义：表示相互行为的代词式动词其主语应为复数名词或代词<ul><li>Les deux amis se rencontrent. 两个朋友相遇（se 是 rencontrer 的直接宾语）</li><li>Ils se serrent la main et se disent bonjour. 他们互相握手问好（la main 和 bonjour 分别是 serrer 和 dire 的直接宾语，两个 se 是间接宾语）</li></ul></li></ol><p>位置：在句子中，自反代词的位置和作宾语用的人称代词的位置相同<br> + Est-ce que tu te couches tôt le soir?</p><p>但在命令式中有两种情况：</p><ol><li>肯定命令式中，代词放动词后，te 改为 toi，其他不变<ul><li>Lève-toi!Levez-vous! 起来！</li></ul></li><li>否定命令式中，代词放动词前<ul><li>Ne te lève pas! 别过来！</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leçon-treize&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#leçon-treize&quot;&gt;#&lt;/a&gt; LEÇON TREIZE&lt;/h1&gt;
&lt;h2 id=&quot;缩合冠词&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#缩合冠词&quot;&gt;#&lt;/a&gt; 缩合冠词</summary>
      
    
    
    
    <category term="法语" scheme="https://osakana373.github.io/categories/French/"/>
    
    <category term="法语语法" scheme="https://osakana373.github.io/categories/French/grammar/"/>
    
    
    <category term="法语" scheme="https://osakana373.github.io/tags/%E6%B3%95%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>french-grammar-9-12</title>
    <link href="https://osakana373.github.io/French/grammar/french-grammar-9-12/french-grammar-9-12/"/>
    <id>https://osakana373.github.io/French/grammar/french-grammar-9-12/french-grammar-9-12/</id>
    <published>2023-09-27T07:30:34.000Z</published>
    <updated>2023-10-12T06:58:21.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leçon-neuf"><a class="anchor" href="#leçon-neuf">#</a> LEÇON NEUF</h1><h2 id="省略冠词的几种情况"><a class="anchor" href="#省略冠词的几种情况">#</a> 省略冠词的几种情况</h2><ol><li>名词前有其他限定词</li><li>名词作表语，说明身份或国籍</li><li>介词 en 后的名词不用冠词</li><li>名词通过介词 de 作名词补语并表示性质</li></ol><ul><li>Je suis dans le département de français.</li><li>注意：如果表示所属关系，则不能省略<ul><li>le magnétophone de la classe A. （A 班的录音机）</li></ul></li></ul><h2 id="序数词"><a class="anchor" href="#序数词">#</a> 序数词</h2><p>除 premier 外，其他序数词均由数词词根加后缀 - ième 构成（以 e 结尾，则去 e 加 - ième）</p><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">un, une</th><th style="text-align:center">premier, première</th></tr></thead><tbody><tr><td style="text-align:center">2</td><td style="text-align:center">deux</td><td style="text-align:center">deuxième 或 second,seconde</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">trois</td><td style="text-align:center">troisième</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">quatre</td><td style="text-align:center">quatrième</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">cinq</td><td style="text-align:center">cinqième</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">six</td><td style="text-align:center">sixième</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">sept</td><td style="text-align:center">septième</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">huit</td><td style="text-align:center">huitième</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">neuf</td><td style="text-align:center">neuvième</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">dix</td><td style="text-align:center">dixième</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">onze</td><td style="text-align:center">onzième</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">douze</td><td style="text-align:center">douzième</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">vingt</td><td style="text-align:center">vingtième</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">vingt et un</td><td style="text-align:center">vingt et unième</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">vingt-deux</td><td style="text-align:center">vingt-deuxième</td></tr><tr><td style="text-align:center">30</td><td style="text-align:center">trente</td><td style="text-align:center">trentième</td></tr></tbody></table><h1 id="leçon-dix"><a class="anchor" href="#leçon-dix">#</a> LEÇON DIX</h1><h2 id="主有形容词"><a class="anchor" href="#主有形容词">#</a> 主有形容词</h2><p>用来表示领属关系，要与<strong>所限定的名词</strong>的性、数相一致，而与占有者的性、数无关。</p><table><thead><tr><th style="text-align:center">阳性单数</th><th style="text-align:center">阴性单数</th><th style="text-align:center">复数</th><th style="text-align:center">释义</th></tr></thead><tbody><tr><td style="text-align:center">mon</td><td style="text-align:center">ma</td><td style="text-align:center">mes</td><td style="text-align:center">我的</td></tr><tr><td style="text-align:center">ton</td><td style="text-align:center">ta</td><td style="text-align:center">tes</td><td style="text-align:center">你的</td></tr><tr><td style="text-align:center">son</td><td style="text-align:center">sa</td><td style="text-align:center">ses</td><td style="text-align:center">他（她）的</td></tr><tr><td style="text-align:center">notre</td><td style="text-align:center">notre</td><td style="text-align:center">nos</td><td style="text-align:center">我们的</td></tr><tr><td style="text-align:center">votre</td><td style="text-align:center">votre</td><td style="text-align:center">vos</td><td style="text-align:center">你们的</td></tr><tr><td style="text-align:center">leur</td><td style="text-align:center">leur</td><td style="text-align:center">leurs</td><td style="text-align:center">他（她）们的</td></tr></tbody></table><p>注意： 在以<strong>元音字母或哑音 h 开头</strong>的名词前，ma、ta、sa 因读音需要改为：mon、ton、son。</p><ul><li>mon école 我的学校</li><li>ton usine 你的工厂</li></ul><h2 id="第一组动词的直陈式现在时"><a class="anchor" href="#第一组动词的直陈式现在时">#</a> 第一组动词的直陈式现在时</h2><p>以 er 结尾：除 aller 外</p><table><thead><tr><th style="text-align:center">je ... e</th><th style="text-align:center">nous ... ons</th></tr></thead><tbody><tr><td style="text-align:center">tu ... es</td><td style="text-align:center">vous ... ez</td></tr><tr><td style="text-align:center">il ... e</td><td style="text-align:center">ils ... ent</td></tr><tr><td style="text-align:center">elle ... e</td><td style="text-align:center">elles ... ent</td></tr></tbody></table><p>aller 的直陈式现在时：</p><table><thead><tr><th style="text-align:center">je vais</th><th style="text-align:center">nous allons</th></tr></thead><tbody><tr><td style="text-align:center">tu vas</td><td style="text-align:center">vous allez</td></tr><tr><td style="text-align:center">il va</td><td style="text-align:center">ils vont</td></tr><tr><td style="text-align:center">elle va</td><td style="text-align:center">elles vont</td></tr></tbody></table><h2 id="de代替des"><a class="anchor" href="#de代替des">#</a> de 代替 des</h2><p>在<strong>否定句</strong>中，<strong>直接宾语</strong>前的<strong>不定冠词</strong> un,une,des 用 de 代替</p><ul><li>J'ai un frère, mais je n'ai pas de sœur.</li></ul><h1 id="leçon-onze"><a class="anchor" href="#leçon-onze">#</a> LEÇON ONZE</h1><h2 id="指示形容词"><a class="anchor" href="#指示形容词">#</a> 指示形容词</h2><p>性、数要与<strong>所限定的名词</strong>性、数相一致</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">阳性名词前</th><th style="text-align:center">阴性名词前</th></tr></thead><tbody><tr><td style="text-align:center">单数</td><td style="text-align:center">ce (roman)</td><td style="text-align:center">cette</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">cet (hôtel)</td><td style="text-align:center">cette</td></tr><tr><td style="text-align:center">复数</td><td style="text-align:center">ces</td><td style="text-align:center">ces</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">ces</td><td style="text-align:center">ces</td></tr></tbody></table><p><strong>cet</strong> 用在以<strong>元音字母或哑音 h</strong> 开始的名词前</p><ul><li>ce、cet、cette 均可为 this、that</li><li>ces 可为 these、those</li></ul><h2 id="重度人称代词"><a class="anchor" href="#重度人称代词">#</a> 重度人称代词</h2><table><thead><tr><th style="text-align:center">单数</th><th style="text-align:center"></th><th style="text-align:center">复数</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">moi</td><td style="text-align:center">我</td><td style="text-align:center">nous</td><td style="text-align:center">我们</td></tr><tr><td style="text-align:center">toi</td><td style="text-align:center">你</td><td style="text-align:center">vous</td><td style="text-align:center">您，你们</td></tr><tr><td style="text-align:center">lui</td><td style="text-align:center">他</td><td style="text-align:center">eux</td><td style="text-align:center">他们</td></tr><tr><td style="text-align:center">elle</td><td style="text-align:center">她</td><td style="text-align:center">elles</td><td style="text-align:center">她们</td></tr></tbody></table><h3 id="用法"><a class="anchor" href="#用法">#</a> 用法</h3><ol><li>强调主语<ul><li>Lui, il est Français. 他吗，他是法国人</li></ul></li><li>作表语（一般在 c'est 后使用）<ul><li>C'est Phillippe? Oui, c'est moi.</li></ul></li><li>用于介词后<ul><li>Ce roman est à elle. 这本小说是她的</li></ul></li><li>用于省略句<ul><li>Et vous? 您呢？</li></ul></li></ol><h2 id="专有名词前的冠词"><a class="anchor" href="#专有名词前的冠词">#</a> 专有名词前的冠词</h2><ul><li>国名 le Japon</li><li>城市名前不加 Paris</li><li>人名前不加 Bernard</li></ul><p>注意：</p><ul><li>表示特指，需要加阳性冠词： le Paris des années 50</li><li>表示 ' 某某一家人‘，用 les： les Morin</li></ul><h1 id="leçon-douze"><a class="anchor" href="#leçon-douze">#</a> LEÇON DOUZE</h1><h2 id="形容词"><a class="anchor" href="#形容词">#</a> 形容词</h2><h3 id="阳性形容词变阴性"><a class="anchor" href="#阳性形容词变阴性">#</a> 阳性形容词变阴性</h3><ol><li>以 'e' 结尾，变阴性是形式不变<ul><li>un texte difficile</li></ul></li><li>以元音结尾，变阴性时词末加 'e'<ul><li>un joli manteau</li><li>une jolie robe</li></ul></li><li>以辅音字母结尾，变阴性时词末加 'e'，词末辅音字母发音<ul><li>un homme intelligent</li><li>une femme intelligente</li></ul></li><li>'er' 变 'ère'<ul><li>un étudiant étranger</li><li>une étudiante étrangère</li></ul></li><li>'x' 变'se'[z]<ul><li>Il est sérieux</li><li>Elle est sérieuse</li></ul></li></ol><p>特殊情况：</p><ul><li>un beau manteau -- une belle robe</li><li>un vieux manteau -- une vieille robe</li></ul><h3 id="形容词复数的构成"><a class="anchor" href="#形容词复数的构成">#</a> 形容词复数的构成</h3><ol><li>一般加's'<ul><li>moderne -- modernes</li></ul></li><li>形容词的阳性单数如果以 x 或 s 结尾，复数不变<ul><li>Il est heureaux</li><li>Ils sont heureaux</li><li>但 Elles sont heureuses</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leçon-neuf&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#leçon-neuf&quot;&gt;#&lt;/a&gt; LEÇON NEUF&lt;/h1&gt;
&lt;h2 id=&quot;省略冠词的几种情况&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#省略冠词的几种情况&quot;&gt;#&lt;/a&gt; </summary>
      
    
    
    
    <category term="法语" scheme="https://osakana373.github.io/categories/French/"/>
    
    <category term="法语语法" scheme="https://osakana373.github.io/categories/French/grammar/"/>
    
    
    <category term="法语" scheme="https://osakana373.github.io/tags/%E6%B3%95%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>french-grammar-1-8</title>
    <link href="https://osakana373.github.io/French/grammar/french-grammar-1-8/french-grammar-1-8/"/>
    <id>https://osakana373.github.io/French/grammar/french-grammar-1-8/french-grammar-1-8/</id>
    <published>2023-09-27T01:46:02.000Z</published>
    <updated>2023-09-27T07:28:30.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="悦学法语"><a class="anchor" href="#悦学法语">#</a> 悦学法语</h1><p>对法语入门班内容进行语法整理。</p><h2 id="特殊疑问句"><a class="anchor" href="#特殊疑问句">#</a> 特殊疑问句</h2><ul><li>Qui 谁   Qui est votre professeur?</li><li>Que 多么，多少   Qu'est-ce que vous faites?（你在做什么？）</li><li>Où 在... 地方   Vous habitez où?</li><li>Comment 如何，怎样，为何   Comment allez-vous?（你好吗？）</li></ul><h2 id="疑问形容词和感叹形容词"><a class="anchor" href="#疑问形容词和感叹形容词">#</a> 疑问形容词和感叹形容词</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">单数</th><th style="text-align:center"></th><th style="text-align:center">复数</th><th></th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">阳性</td><td style="text-align:center">阴性</td><td style="text-align:center">阳性</td><td>阴性</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">quel</td><td style="text-align:center">quelle</td><td style="text-align:center">quels</td><td>quelles</td></tr></tbody></table><p>疑问形容词表示疑问，在句中作限定语或表语：</p><ul><li>Quel est son nom? 他叫什么名字？</li><li>Quelle heure est-il? 几点了？</li><li>Quels livres prenez-vous? 您要取什么书？</li><li>Quelles sont ces voitures? 这是些什么车？</li></ul><p>感叹形容词表示赞赏、厌恶、愤怒等：</p><ul><li>Quel beau temps! 多么好的天气！</li></ul><h2 id="介词à和de的用法"><a class="anchor" href="#介词à和de的用法">#</a> 介词 à 和 de 的用法</h2><h3 id="à引出时间或地点状语"><a class="anchor" href="#à引出时间或地点状语">#</a> à 引出时间或地点状语</h3><ul><li>Je suis à l'heure. 我很准时</li><li>Il est temps d'entrer au cinéma. 是时候去电影院了（au=à+le）</li></ul><h3 id="de"><a class="anchor" href="#de">#</a> de</h3><p>相当于英文中的 of，表示... 的</p><h1 id="leçon-six"><a class="anchor" href="#leçon-six">#</a> LEÇON SIX</h1><h2 id="名词复数"><a class="anchor" href="#名词复数">#</a> 名词复数</h2><p>一般在词尾加上‘s'</p><p>特殊情况：</p><ul><li>-al -aux</li><li>-au -aux</li><li>-eau -eaux</li><li>-eu -eux</li><li>-ou -ous</li><li>-ail -ails</li></ul><h2 id="一般否定"><a class="anchor" href="#一般否定">#</a> 一般否定</h2><p>否定用 ne...pas，ne 放在动词前，pas 放在动词后</p><ul><li>Ce ne sont pas des chaises.</li></ul><h2 id="疑问句的4种基本形式"><a class="anchor" href="#疑问句的4种基本形式">#</a> 疑问句的 4 种基本形式</h2><h3 id="陈述句句末语调上升"><a class="anchor" href="#陈述句句末语调上升">#</a> 陈述句句末语调上升</h3><ul><li>Il est journaliste?</li></ul><h3 id="陈述句前加est-ce-que"><a class="anchor" href="#陈述句前加est-ce-que">#</a> 陈述句前加 est-ce que</h3><ul><li>Est-ce que c'est Philippe?</li></ul><h3 id="主语和动词倒装"><a class="anchor" href="#主语和动词倒装">#</a> 主语和动词倒装</h3><ul><li>Est-ce que un stylo?</li></ul><h3 id="名词主语动词代词主语其他成分"><a class="anchor" href="#名词主语动词代词主语其他成分">#</a> 名词主语 + 动词 + 代词主语 + 其他成分</h3><h1 id="leçon-sept"><a class="anchor" href="#leçon-sept">#</a> LEÇON SEPT</h1><h2 id="作主语的人称代词"><a class="anchor" href="#作主语的人称代词">#</a> 作主语的人称代词</h2><table><thead><tr><th style="text-align:center">单数</th><th style="text-align:center"></th><th style="text-align:center">复数</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">je</td><td style="text-align:center">我</td><td style="text-align:center">nous</td><td style="text-align:center">我们</td></tr><tr><td style="text-align:center">tu</td><td style="text-align:center">你</td><td style="text-align:center">vous</td><td style="text-align:center">你们</td></tr><tr><td style="text-align:center">il</td><td style="text-align:center">他</td><td style="text-align:center">ils</td><td style="text-align:center">他们</td></tr><tr><td style="text-align:center">elle</td><td style="text-align:center">她</td><td style="text-align:center">elles</td><td style="text-align:center">她们</td></tr></tbody></table><h2 id="阳性名词变阴性名词"><a class="anchor" href="#阳性名词变阴性名词">#</a> 阳性名词变阴性名词</h2><h3 id="表示人的国籍-职业和身份词尾加字母e"><a class="anchor" href="#表示人的国籍-职业和身份词尾加字母e">#</a> 表示人的国籍、职业和身份，词尾加字母 e</h3><ul><li>un Chinois -&gt; une Chinoise</li></ul><h3 id="-ien-ienne"><a class="anchor" href="#-ien-ienne">#</a> -ien -&gt; -ienne</h3><ul><li>un technicien -&gt; une technicienne</li></ul><h3 id="-eur-rice"><a class="anchor" href="#-eur-rice">#</a> -eur -&gt; -rice</h3><ul><li>un acteur -&gt; une actrice</li></ul><p>有时 -eur -&gt; -euse:</p><ul><li>un chanteur -&gt; une chanteuse</li></ul><h3 id="不分阴阳性"><a class="anchor" href="#不分阴阳性">#</a> 不分阴阳性</h3><ul><li>un/une journaliste</li></ul><h3 id="有些名词由于历史原因只有阳性"><a class="anchor" href="#有些名词由于历史原因只有阳性">#</a> 有些名词由于历史原因，只有阳性</h3><ul><li>professeur, médecin, ingénieur, pilote</li></ul><h1 id="leçon-huit"><a class="anchor" href="#leçon-huit">#</a> LEÇON HUIT</h1><h2 id="年龄表达法"><a class="anchor" href="#年龄表达法">#</a> 年龄表达法</h2><p>使用动词 avoir</p><ul><li>Quel âge a-t-il?  -- How old is he?</li><li>Il a vingt ans. -- He is 20.</li></ul><h2 id="书写规范"><a class="anchor" href="#书写规范">#</a> 书写规范</h2><ul><li>专有名词、橘子、标题的第一个字母要大写</li><li>每段开始时，应缩后 5 个字母的位置</li></ul><h1 id="走遍法国-épisode-3"><a class="anchor" href="#走遍法国-épisode-3">#</a> 走遍法国 ÉPISODE 3</h1><h2 id="介词pour为了表达对象或目的"><a class="anchor" href="#介词pour为了表达对象或目的">#</a> 介词 pour（为了）—— 表达对象或目的</h2><ol><li>pour + 人名</li></ol><ul><li>C'est pour qui? - C;est pour Julie/elle.</li></ul><ol start="2"><li>表达目的 pour + 事物名词</li></ol><ul><li>C'est pour quoi? 这是为了什么？</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;悦学法语&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#悦学法语&quot;&gt;#&lt;/a&gt; 悦学法语&lt;/h1&gt;
&lt;p&gt;对法语入门班内容进行语法整理。&lt;/p&gt;
&lt;h2 id=&quot;特殊疑问句&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#特殊疑问句&quot;&gt;#&lt;/a&gt; 特殊疑</summary>
      
    
    
    
    <category term="法语" scheme="https://osakana373.github.io/categories/French/"/>
    
    <category term="法语语法" scheme="https://osakana373.github.io/categories/French/grammar/"/>
    
    
    <category term="法语" scheme="https://osakana373.github.io/tags/%E6%B3%95%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>review</title>
    <link href="https://osakana373.github.io/Undergraduate-computer-course/nlp/review/"/>
    <id>https://osakana373.github.io/Undergraduate-computer-course/nlp/review/</id>
    <published>2022-01-03T14:25:34.000Z</published>
    <updated>2022-01-04T03:05:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分词"><a class="anchor" href="#分词">#</a> 分词</h1><p>为什么需要分词？</p><ul><li>在自然语言处理领域，信息处理的最小单位一般是词</li><li>在中文里，词和词之间没有天然的分隔，比如空格，因此在进行其他任务之前，通常需要分词</li></ul><h2 id="分词算法"><a class="anchor" href="#分词算法">#</a> 分词算法</h2><ul><li>查词典法<ul><li>最大匹配法</li><li>最大概率法</li></ul></li><li>序列标注法</li><li>N - 最短路径法</li></ul><h2 id="新词发现"><a class="anchor" href="#新词发现">#</a> 新词发现</h2><p>为什么需要新词发现？</p><ul><li>基于词典的分词方法对于没在词典的词（新词）没办法处理</li><li>新词也称为未登录词</li><li>人名、地名、机构名、品牌名、专业名词、缩略语、网络新词</li></ul><p>新词发现的思路：</p><ul><li>根据语料（文本数据）中词的一些特征，将语料中可能的词提取出来</li><li>再把所有提取出来的词和词典里的词进行比较</li><li>不在词典里的词就是新词</li></ul><p>新词特征：频率、内部凝固度（互信息）、外部自由度（信息熵）</p><h1 id="词向量"><a class="anchor" href="#词向量">#</a> 词向量</h1><h2 id="名词解释"><a class="anchor" href="#名词解释">#</a> 名词解释</h2><p>分词：将句子、段落、文章这种长文本，分解为以字词为单位的数据结构，方便后续的处理分析工作</p><p>词向量：用来表示词的向量，也可被认为是词的特征向量或表征。词向量本质是将一些低维、离散、不带任何意义的序号映射成带有特定任务性质的高维特征。</p><h3 id="语言模型"><a class="anchor" href="#语言模型">#</a> 语言模型</h3><p>语言模型：计算一个词出现的概率，极大似然估计；计算一段文字出现的概率</p><p>n 元语法模型：一个词出现的概率只和它前面 n-1 个词相关</p><p>数据平滑的基本思想：调整概率值，使零概率增值，使非零概率下调，改进模型的整体性能（加 1 法，Good-Turing 平滑）</p><p>Good-Turing 平滑：将已经出现的词的概率进行打折，打折后分出一部分概率给没有出现的词</p><h3 id="神经语言模型"><a class="anchor" href="#神经语言模型">#</a> 神经语言模型</h3><p>独热向量：每个词对应一维；向量的总维数为词表大小</p><p>例如：Wuhan University is located in Hubei，则 University 的 one-hot 为：0 1 0 0 0 0 0</p><p>输入层：n-1 个词的词向量串接</p><p>隐层：y = f (Wx+b)</p><ul><li>x 输入向量</li><li>W 参数矩阵</li><li>b 偏置向量</li><li>f 激励函数（sigmoid, tanh）</li><li>y 输出向量</li></ul><p>输出层：softmax</p><p><img data-src="1.png" alt></p><h2 id="word2vec"><a class="anchor" href="#word2vec">#</a> Word2Vec</h2><p>Word embedding: 把词表示成一个固定维数的向量</p><p>向量的每一维都是参数，是从大规模的文本中训练出来</p><ul><li>Word2Vec 的参数一个是 C，一个是 W，其中 C 就是词向量的查找表，其中每一行（或每一列）就是我们常说的词向量</li><li>模型训练好后，我们可以把 C 保存下来</li><li>Word2Vec 的主要计算量在输出层</li><li>因为词表 | V | 很大，所以 softmax 的计算量很大</li><li>Word2Vec 提出两种加快训练速度的方式，思想都是减少 softmax 计算</li></ul><p>Word2Vec 和 Glove 均可以训练词向量</p><h1 id="文本分类"><a class="anchor" href="#文本分类">#</a> 文本分类</h1><h2 id="文本分类任务介绍"><a class="anchor" href="#文本分类任务介绍">#</a> 文本分类任务介绍</h2><p>任务定义：输入一个句子或一段文本，输出句子或者文本的类别（情感分类、关系分类）。</p><p>常用方法：</p><ul><li>统计机器学习：支持向量机 SVM、最大熵模型</li><li>深度学习：卷积神经网络 CNN、循环神经网络 RNN</li></ul><h2 id="基于cnn的文本分类"><a class="anchor" href="#基于cnn的文本分类">#</a> 基于 CNN 的文本分类</h2><p>卷积：用卷积核在序列上进行重复的类似的计算。</p><p>卷积目的：单个词表达的意义是有限的，让词和它的上下文互相感知，从而丰富词的语义</p><p>池化：将多个向量变成一个向量</p><p>基于 CNN 的文本分类总结：</p><ul><li>利用卷积学习词和词的上下文特征</li><li>利用池化将一个变长的句子转化为一个定长的特征向量</li><li>特征向量用于输出层做文本分类<ul><li>softmax</li></ul></li></ul><p>TextCNN：定义了 6 个卷积核（4x5,3x5,2x5 各两个）</p><p>TextCNN 总结：</p><ul><li>CNN 可以有多个核，每个核的窗口大小不一样</li><li>便于捕捉 n 元特征（2 元，3 元，4 元，...）</li><li>多个核产生的特征，通过串接组合在一起，生成特征向量</li><li>特征向量用于输出层做文本分类</li></ul><h2 id="基于cnn的关系分类"><a class="anchor" href="#基于cnn的关系分类">#</a> 基于 CNN 的关系分类</h2><h3 id="关系分类的任务介绍"><a class="anchor" href="#关系分类的任务介绍">#</a> 关系分类的任务介绍</h3><p>给定两个实体 (人名、地名、组织结构名等等)，判断两个实体之间的关系（分类），例如：小李出生在中国（出生在就是关系）</p><p>基于 CNN：</p><ul><li>句子</li><li>词表示</li><li>卷积</li><li>池化</li><li>输出层</li></ul><p>加入 Attention 机制后：</p><ul><li>句子</li><li>词表示</li><li>注意力 Attention</li><li>卷积</li><li>Attention</li><li>输出层</li></ul><p>CNN 可以和其他神经网络，如前馈神经网络、循环神经网络、Attention 网络进行组合使用</p><p>分类模型的要素:</p><ul><li>输入</li><li>隐层</li><li>输出层</li><li>损失函数</li></ul><h3 id="注意力机制"><a class="anchor" href="#注意力机制">#</a> 注意力机制</h3><p>目的：学习每个词对于任务的贡献率</p><ul><li>输入：一个向量序列</li><li>“something” attention on 向量序列 ，计算 attention score</li><li>通过 softmax 归一化 attention score</li></ul><p>Attention score 的用途：</p><ul><li>可以用来衡量每个词的贡献</li><li>可以用来进行加权平均，得到特征</li></ul><h1 id="词性标注"><a class="anchor" href="#词性标注">#</a> 词性标注</h1><h2 id="任务介绍"><a class="anchor" href="#任务介绍">#</a> 任务介绍</h2><p>词性标注，就是给每个词一个词性</p><p>HMM（隐马尔可夫模型）可用于词性标注：</p><ul><li>训练数据</li><li>计算马尔可夫模型的参数<ul><li>利用极大似然估计</li></ul></li><li>预测一个句子中，每个词的词性<ul><li>Viterbi 算法（词性预测）</li></ul></li></ul><p>HMM 参数：</p><ul><li>隐状态</li><li>观察值</li><li>转移概率</li><li>发射概率</li></ul><h1 id="实体识别"><a class="anchor" href="#实体识别">#</a> 实体识别</h1><h2 id="任务介绍-2"><a class="anchor" href="#任务介绍-2">#</a> 任务介绍</h2><p>实体识别（NER）定义：识别出文本中实体（人名、机构名、地名、时间、日期等）</p><p>两个子任务：</p><ul><li>实体边界识别</li><li>确定实体类别</li></ul><p>方法：把实体识别看成序列标注任务，为句子中的每一个词打标签</p><p>基于 Bi-directional LSTM CRF 的实体识别：</p><ul><li>词向量层</li><li>双向 LSTM 层</li><li>CRF 层</li></ul><h2 id="循环神经网络"><a class="anchor" href="#循环神经网络">#</a> 循环神经网络</h2><p>变体：LSTM、GRU</p><h3 id="lstm"><a class="anchor" href="#lstm">#</a> LSTM</h3><p>LSTM：全名为 Long Shoort Term 网络，是一种 RNN 特殊的类型，可以学习长期依赖信息。LSTM 通过刻意的设计来避免长期依赖问题。记住长期的信息在实践中是 LSTM 的默认行为，而非需要付出很大代价才能获得的能力。</p><p>LSTM 的核心概念在于细胞状态以及 “门” 结构。</p><p>细胞状态相当于信息传输的路径，让信息能在序列连中传递下去。理论上讲，细胞状态能够将序列处理过程中的相关信息一直传递下去。因此，即使是较早时间步长的信息也能携带到较后时间步长的细胞中来，这克服了短时记忆的影响。</p><p>信息的添加和移除我们通过 “门” 结构来实现，“门” 结构在训练过程中会去学习该保存或遗忘哪些信息。</p><p>遗忘门：决定应丢弃或保留哪些信息。来自前一个隐藏状态的信息和当前输入的信息同时传递到 sigmoid 函数中去，输出值介于 0 和 1 之间，越接近 0 意味着越应该丢弃，越接近 1 意味着越应该保留。</p><p>输入门：用于更新细胞状态。首先将前一层隐藏状态的信息和当前输入的信息传递到 sigmoid 函数中去。将值调整到 01 之间来决定要更新哪些信息。0 表示不重要，1 表示重要。其次还要将前一层隐藏状态的信息和当前输入的信息传递到 tanh 函数中去，创造一个新的侯选值向量。最后将 sigmoid 的输出值与 tanh 的输出值相乘，sigmoid 的输出值将决定 tanh 的输出值中哪些信息是重要且需要保留下来的。</p><p>细胞状态：更新旧细胞状态。我们把旧状态与遗忘门输出值相乘，丢弃掉我们确定需要丢弃的信息。接着加上输入门输出的值（sigmoid 的输出值与 tanh 的输出值相乘），这就是新的候选值，根据我们决定更新每个状态的程度进行变化。</p><p>输出门：用来确定下一个隐藏状态的值，隐藏状态包含了先前输入的信息。首先，我们将前一个隐藏状态和当前输入传递到 sigmoid 函数中，然后将新得到的细胞状态传递给 tanh 函数。最后将 tanh 的输出与 sigmoid 的输出相乘，以确定隐藏状态应携带的信息。再将隐藏状态作为当前细胞的输出，把新的细胞状态和新的隐藏状态传递到下一个时间步长中去。</p><p><img data-src="LSTM.png" alt></p><p>LSTM 和 GRU 的比较:</p><ul><li>LSTM：输入门，输出门，遗忘门，cell state</li><li>GRU：更新门，重置门，输出门</li></ul><p>循环神经网络可用于特征抽取</p><h2 id="条件随机场crf"><a class="anchor" href="#条件随机场crf">#</a> 条件随机场 CRF</h2><p>输入：句子<br>输出：标签序列</p><p>总结：</p><ul><li>利用神经网络进行文本特征抽取</li><li>不仅考虑标签本身，也考虑标签的转移得分（对比 softmax）</li><li>CRF 可以选择更丰富的特征</li></ul><h2 id="不规则命名实体识别方法比较"><a class="anchor" href="#不规则命名实体识别方法比较">#</a> 不规则命名实体识别方法比较</h2><p><img data-src="2.png" alt></p><h1 id="句法分析"><a class="anchor" href="#句法分析">#</a> 句法分析</h1><p>概率上下文无关句法 PCFG</p><h1 id="依存分析"><a class="anchor" href="#依存分析">#</a> 依存分析</h1><p>定义：基于依存文法的句法分析。分析结果为句子中词语间依存关系组成的依存树。</p><p>每个依存关系由一个中心词 (Head) 和一个依赖词 (Dependent) 组成</p><p>基于转换的 (transition-based) 依存句法分析：</p><ul><li>将依存分析转化为操作序列生成的问题</li><li>训练模型<ul><li>给一些训练数据（依存树库）</li><li>训练一个分类器，能够生成如下操作组成的序列<ul><li>Shift</li><li>Left arc</li><li>Right arc</li></ul></li></ul></li><li>预测时<ul><li>输入：一个句子</li><li>输出：操作序列</li><li>解码：使用操作序列将句子转化为依存树</li></ul></li></ul><h1 id="预训练"><a class="anchor" href="#预训练">#</a> 预训练</h1><p>训练指为了某个特定任务，使用人工标注的数据，训练模型（比如实体识别）</p><p>预训练也是训练模型，不过是使用大规模无人工标注的数据，进行训练</p><ul><li>标注是数据里自带的，也叫做自监督训练</li><li>可以看成无监督学习的一种</li></ul><p>word2vec 中也用过预训练</p><p>与训练模型：ELMo、GPT、BERT</p><ul><li>BERT 本质上是一个基于 Transformer 的预训练语言模型，只有 Transformer 的 Encoder</li><li>GPT 也一个基于 Transformer 的预训练语言模型，只有 Transformer 的 Decoder</li><li>ELMo 是一个基于 LSTM 的语言模型，由 forward 和 backward LSTM 组成</li></ul><h2 id="gpt和bert比较"><a class="anchor" href="#gpt和bert比较">#</a> GPT 和 BERT 比较</h2><p>GPT (Generative Pre-Training) 和 BERT (Bidirectional Encoder Representation from Transformers) 都是以 Transformer 为主题架构的预训练语言模型，都是通过 “预训练 + fine tuning” 的模式下完成下游任务的搭建</p><ul><li>GPT 是单向模型，无法利用上下文信息，只能利用上文；而 BERT 是双向模型</li><li>GPT 是基于自回归模型，可以应用在 NLU 和 NLG 两大任务，而原生的 BERT 采用的基于自编码模型，只能完成 NLU 任务，无法直接应用在文本生成上面</li><li>同等参数规模下，BERT 的效果要好于 GPT</li></ul><h1 id="词汇处理"><a class="anchor" href="#词汇处理">#</a> 词汇处理</h1><p>词义排岐：给定一个词及其上下文，如果其义项出现在训练集中，则确定其义项</p><p>词义学习：给定一个词及其上下文，如果其义项不在训练集中，则学习其新义项，并抽取上下文特征作为该义项的标记</p><h1 id="结构分析"><a class="anchor" href="#结构分析">#</a> 结构分析</h1><p>语言结构：一个语言单位的组成部分及其关系组成的结构体<br>语言单位：短语、句子、段落、篇章<br>组成部分：字、词、短语、句子、段落、篇章</p><p>句法关系：反映句子组成层面的关系，回答句子是否合法的问题</p><p>语义关系：反映组成部分深层的关系</p><p>句法和语义：句法关心一个语言单位是否满足语法，语义关心一个语言单位所表达的意义</p><p>句法结构：语言成分及其句法关系组成的结构<br>依存结构：词汇间的依存关系组成的结构<br>块结构：句法块及其句法关系组成的结构</p><p>结构预测模型：</p><ul><li>基于转移的模型：有限自动机</li><li>基于图的模型：图空间</li></ul><h1 id="篇章分析"><a class="anchor" href="#篇章分析">#</a> 篇章分析</h1><p>回指：语法描写中用来指一个语言单位从先前某个已表达的单位或意义（先行词）得出自身释义的过程或结果</p><p>零形回指（zero anaphora）是小句中有指称前文语段的意义，但没有借助语音或者词汇形式的回指现象</p><h1 id="情感分析"><a class="anchor" href="#情感分析">#</a> 情感分析</h1><p>情感分析定义：社交媒体针对特定对象的主观反应或自身的情绪状态，前者包括极性、立场、意见、态度等；后者包括情绪表达 / 诱因抽取和分类</p><p>社交媒体文本挖掘：</p><ul><li>数据层：数据采集</li><li>资源层：知识图谱 标注数据</li><li>技术层：知识挖掘 情感分析</li><li>功能层：情报生成 预警预测</li></ul><h1 id="语义分析"><a class="anchor" href="#语义分析">#</a> 语义分析</h1><p>语义结构：自然语言所描述的语义要素及其关系</p><h1 id="实验"><a class="anchor" href="#实验">#</a> 实验</h1><p>文本分类任务基本流程：<br>安装并导入相关的深度学习库、数据获取和预处理、定义神经网络、定义损失函数 (loss function) 和优化器 (optimizer)、训练网络和测试网络</p><p>一个常规的序列标注任务代码开发流程是：安装并导入相关的深度学习库、定义标签集合 (Label set)、数据获取和预处理、定义神经网络、定义损失函数 (loss function) 和优化器 (optimizer)、训练网络和测试网络。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分词&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#分词&quot;&gt;#&lt;/a&gt; 分词&lt;/h1&gt;
&lt;p&gt;为什么需要分词？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在自然语言处理领域，信息处理的最小单位一般是词&lt;/li&gt;
&lt;li&gt;在中文里，词和词之间没有天然的分隔，比如空格，因此在进</summary>
      
    
    
    
    <category term="计算机本科课程" scheme="https://osakana373.github.io/categories/Undergraduate-computer-course/"/>
    
    <category term="人工智能" scheme="https://osakana373.github.io/categories/Undergraduate-computer-course/AI/"/>
    
    <category term="自然语言处理" scheme="https://osakana373.github.io/categories/Undergraduate-computer-course/AI/nlp/"/>
    
    
    <category term="计算机本科课程" scheme="https://osakana373.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>review</title>
    <link href="https://osakana373.github.io/Undergraduate-computer-course/public-opinion-analysis/review/"/>
    <id>https://osakana373.github.io/Undergraduate-computer-course/public-opinion-analysis/review/</id>
    <published>2021-12-24T13:28:17.000Z</published>
    <updated>2021-12-26T06:54:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章舆情分析概述"><a class="anchor" href="#第一章舆情分析概述">#</a> 第一章：舆情分析概述</h1><h2 id="舆情与网络舆情"><a class="anchor" href="#舆情与网络舆情">#</a> 舆情与网络舆情</h2><h3 id="定义与分类"><a class="anchor" href="#定义与分类">#</a> 定义与分类</h3><p>《新华字典》释义：百姓的感情、情绪<br>《词源》释义：民众的意愿</p><p>舆情是广大民众对于国家 / 国际政治事务、社会现象、公私权益等问题表达的具有一定强度、倾向性和外显性的意见、观点和情绪。其中，舆情涵盖了六个方面的要素:</p><ol><li>主体：普通民众，而非政府或政治家。</li><li>客体：社会政治、公共事务、社会现象、公私权益等具有公共性的事物</li><li>方面：针对课题的某一维度</li><li>表现：舆情的实质是意见、观点和态度，但它必须通过某种其他人可以观察或者感受的形式表现出来</li><li>强度：情感程度</li><li>倾向：情感极性</li></ol><p>网络舆情的特点：</p><ol><li>意识性：舆情是对客观事实、现象和问题的态度和意见，是对社会存在的反映，主观性。</li><li>历史性：舆情总是要受到主观认识的制约，因此不同社会地位和阶层的民众持有不同的态度、观点、看法和主张，个性化</li><li>评论性：也可以说是舆情的方向性或倾向性，舆情总是针对有政论性的现实、现象和社会问题而发的</li><li>自发性：舆情是社会民众自发产生、传播和接受的，而不是官方或组织自上而下有意、有计划、有组织地精心加工和整理出来的，自发性</li><li>易变性：随认识变化、他人影响、客观变化而变化，易变性</li></ol><h3 id="反沉默螺旋"><a class="anchor" href="#反沉默螺旋">#</a> 反沉默螺旋</h3><p>沉默螺旋理论：来自于伊丽莎白・诺艾尔・诺依曼多年来发展并验证的民意理论，其核心是个人因害怕被群体和社会孤立，在表达意见前会预先估计民意的气候，当意识到自己的意见与大多数人相同时，便会在公众场合公开自己的观点，反之则会隐藏观点。这一趋势呈现螺旋的过程。</p><p>反沉默螺旋：是指在网络传播时代，受众的参与性大大提高，不再只是被动地接受信息，受众可以自由发表或支持 “少数” 意见，此种 “少数” 意见被更多的网民接受，可能发展为与 “多数” 意见势均力敌甚至超越和改变 “多数” 意见的情况。</p><h3 id="其他效应"><a class="anchor" href="#其他效应">#</a> 其他效应</h3><ol><li>羊群效应：从众心理，联合引导</li><li>蝴蝶效应：注重细节，舆情处置</li><li>风暴眼效应：不太类人群，舆情引导</li><li>沉锚效应：第一印象，舆情引导</li><li>近因效应：最近的印象影响较大，切忌虎头蛇尾</li><li>曝光效应：曝光越多，越易有影响力，舆情处置</li><li>骨牌效应：连锁反应，舆情预警</li></ol><h2 id="舆情与舆论"><a class="anchor" href="#舆情与舆论">#</a> 舆情与舆论</h2><h3 id="定义"><a class="anchor" href="#定义">#</a> 定义</h3><p>公众舆论就是由公众的某些重要部分所持有的对某些有争议的问题的一系列看法。    ——《布莱克维尔政治学百科全书》</p><p>所谓舆论乃为民间所持守的、政府要仔细听从和考虑的意见。   —— 李广智：《舆论学通论》</p><p>网络舆论是公众对于公共事务通过信息网络公开表达的具有影响力的意见。  —— 邓新民：《网络舆论与网络舆论的引导》</p><h3 id="舆情与舆论的关系"><a class="anchor" href="#舆情与舆论的关系">#</a> 舆情与舆论的关系</h3><p>在英语中，舆情与舆论实际上是同一个词，即 public opinion。但在中国语境中，舆情与舆论之间既密不可分，又有着较为严格的区别。</p><p>舆情与舆论的主体都是民众群体，而这涉及的客体基本相同，都是政府整治、社会现象、公共事务等。同样具有丰富的政治、文化和心理内涵。而在发展阶段上，二者前后相继，舆情常为前导。舆情经过筛选、过滤和聚合，升华和提炼为舆论，而舆论又反过来对舆情产生作用。</p><p>舆情与舆论之间仍然有着非常明显的区别：</p><ol><li>表达主体：舆论的主体既可以是官方、媒体，也可以是民众，因此，常有 “官方舆论”、“媒体舆论”、与 “民间舆论” 之分，三者之间往往并不总是一致，有时甚至可能相互对立。</li><li>表现形态：舆论一般表现为言论，它可以是语言，也可以是文字。而舆情的表达形态显然更为丰富多样，既可以是语言文字，也可以是行为。</li><li>内涵：舆情包括意见、观点、态度、情绪，甚至部分行为也可以包含其中。而舆论作为舆情升华、提炼后的产物，主要是意见和观点。如果说舆情是混合物的话，那么舆论则相对纯净，成分较为单纯。</li><li>逻辑关系：一般来说，舆情形成在先，与此相对应的舆论形成在后，一些学者讲舆情称为潜舆论。</li></ol><p>舆情：纷繁多样、主流非主流、不稳定</p><p>舆论：相对稳定、主流、较单一</p><h2 id="舆情与民意"><a class="anchor" href="#舆情与民意">#</a> 舆情与民意</h2><h3 id="民意的定义"><a class="anchor" href="#民意的定义">#</a> 民意的定义</h3><p>广大民众对公共事务、社会现象等所表达的意见和看法。</p><p>民意：情绪化、短期利益、易被操控</p><h3 id="舆情-网络舆情与民意的关系"><a class="anchor" href="#舆情-网络舆情与民意的关系">#</a> 舆情、网络舆情与民意的关系</h3><p>舆情的基础就是民意，舆情总是和民意相对应的，有什么样的民意就会表现出什么样的舆情，二者是统一的，内核是一致。不同的是，民意还只是一种心理状态，是一种社会心理事实，而舆情则是上升到意见或态度层面。但无论是公开意见或者不公开的情绪，舆情总是基于民意的生发，是民意的一种表现形态。</p><p>民意：心理状态<br>舆情：主观认知和意见观点<br>舆论：主流稳定性观点</p><p>网络舆情不过是社会舆情的特殊表现形式，是通过网络反映的公众意见</p><h2 id="网民-公民与民众"><a class="anchor" href="#网民-公民与民众">#</a> 网民、公民与民众</h2><p>网民：过去半年内使用互联网的 6 周岁以上的中国公民<br>公民：指具有一国国籍，根据该国宪法和法律享有权利和承担义务的人，也是有权利参与国家政治生活的人，其包含的范围显然比民众小。<br>网民、公民、民众三者中，民众是一个外延很广的概念，它涵括了公民和网民。</p><h2 id="网络舆情的要素"><a class="anchor" href="#网络舆情的要素">#</a> 网络舆情的要素</h2><p>网络舆情的主体，即网络舆情中从事参与活动，表达意见、观点、情绪的网民个体或群体。</p><h3 id="主体分类"><a class="anchor" href="#主体分类">#</a> 主体分类</h3><ol><li>网民个体</li><li>网络参与群体（社团）：以政治参加为目的而结成的具有相对稳定性的网民聚合</li><li>网络集群：一定数量的无组织的网民个体，围绕特定的现实主题，在一定诱发因素的刺激下产生的，以意见的强化与汇聚为特征的，具有现实影响力的网民聚集</li></ol><h3 id="客体分类"><a class="anchor" href="#客体分类">#</a> 客体分类</h3><p>重大社会事件、社会热点焦点、国家利益与民族情感、公共政策决策、公私权益问题</p><p>客体的主要特点：与社会热点高度重合、客体呈现泛化的趋势、客体出现脱域化效应</p><h3 id="表达平台"><a class="anchor" href="#表达平台">#</a> 表达平台</h3><ul><li>BBS / 网络论坛</li><li>新闻跟帖</li><li>博客 / 播客</li><li>微博</li><li>即时通信群主题网站</li><li>以手机为代表的移动通信工具</li></ul><h3 id="表达方式"><a class="anchor" href="#表达方式">#</a> 表达方式</h3><ul><li>造词 / 造句</li><li>贴标签</li><li>人肉搜索</li><li>网络示威 / 爆吧</li><li>更换签名或头像</li><li>网络签名</li><li>恶搞 / 段子 / 表情</li></ul><h1 id="第二章话题与情感"><a class="anchor" href="#第二章话题与情感">#</a> 第二章：话题与情感</h1><h2 id="话题概念"><a class="anchor" href="#话题概念">#</a> 话题概念</h2><p>定义：一个文档或文档集合所描述的主题<br>表示：一个话题可用一个关键词 / 关键短语或一组关键词和关键短语描述</p><h2 id="话题类别"><a class="anchor" href="#话题类别">#</a> 话题类别</h2><p>命名实体：</p><ul><li>具体实体：人物、组织、书籍、歌曲</li><li>抽象实体：政策、观点</li></ul><p>事件：军舰巡航南海、穿越台湾海峡</p><h2 id="话题模型"><a class="anchor" href="#话题模型">#</a> 话题模型</h2><ul><li>多标签问题</li><li>序列标注问题</li><li>文本生成问题</li><li>文本分类问题</li><li>文本聚类问题</li></ul><h1 id="第三章社团发现"><a class="anchor" href="#第三章社团发现">#</a> 第三章：社团发现</h1><p>社团内部：节点密集联结<br>社团之间：节点稀疏联结<br>社团内部的节点：相似的特征或功能</p><h1 id="第四章舆情事件及演化"><a class="anchor" href="#第四章舆情事件及演化">#</a> 第四章：舆情事件及演化</h1><h2 id="舆情事件"><a class="anchor" href="#舆情事件">#</a> 舆情事件</h2><p>事件触发词：谓词、体词、模板<br>事件要素：Agent、Patient、Time、Location</p><p>分清一阶和二阶评价</p><h2 id="事件演化"><a class="anchor" href="#事件演化">#</a> 事件演化</h2><p>内涵：特定舆情事件所引发、伴随的其他次生事件、衍生事件等</p><h1 id="言论和立场抽取"><a class="anchor" href="#言论和立场抽取">#</a> 言论和立场抽取</h1><p>二阶评论：对于评论的评论</p><h1 id="考试题目预测"><a class="anchor" href="#考试题目预测">#</a> 考试题目预测</h1><h2 id="概述"><a class="anchor" href="#概述">#</a> 概述</h2><h3 id="舆情的定义"><a class="anchor" href="#舆情的定义">#</a> 舆情的定义</h3><p>《新华字典》释义：百姓的感情、情绪<br>《词源》释义：民众的意愿</p><p>舆情是广大民众对于国家 / 国际政治事务、社会现象、公私权益等问题表达的具有一定强度、倾向性和外显性的意见、观点和情绪。其中，舆情涵盖了六个方面的要素:</p><ol><li>主体：普通民众，而非政府或政治家。</li><li>客体：社会政治、公共事务、社会现象、公私权益等具有公共性的事物</li><li>方面：针对课题的某一维度</li><li>表现：舆情的实质是意见、观点和态度，但它必须通过某种其他人可以观察或者感受的形式表现出来</li><li>强度：情感程度</li><li>倾向：情感极性</li></ol><h3 id="舆情的特点"><a class="anchor" href="#舆情的特点">#</a> 舆情的特点</h3><ol><li>意识性：舆情是对客观事实、现象和问题的态度和意见，是对社会存在的反映，主观性。</li><li>历史性：舆情总是要受到主观认识的制约，因此不同社会地位和阶层的民众持有不同的态度、观点、看法和主张，个性化</li><li>评论性：也可以说是舆情的方向性或倾向性，舆情总是针对有政论性的现实、现象和社会问题而发的</li><li>自发性：舆情是社会民众自发产生、传播和接受的，而不是官方或组织自上而下有意、有计划、有组织地精心加工和整理出来的，自发性</li><li>易变性：随认识变化、他人影响、客观变化而变化，易变性</li></ol><h3 id="舆情和网络舆情的关系"><a class="anchor" href="#舆情和网络舆情的关系">#</a> 舆情和网络舆情的关系</h3><p>主体：人，互联网上的活动主体 —— 网民实际上就是现实社会中的人，网民在网络上的活动不过是现实社会中活动的眼神和拓展，网络舆情不过是社会舆情在网络空间的映射，是社会舆情的直接反映。</p><p>网络舆情的生成，离不开现实的民意基础；网络舆情是现实舆情在网络空间的反映；网络舆情是社会舆情在网络空间的映射。</p><p>舆情仍是舆情；互联网只是工具</p><p>网络舆情特点：传播速度、影响力、影响范围</p><h3 id="舆情和舆论的关系和区别"><a class="anchor" href="#舆情和舆论的关系和区别">#</a> 舆情和舆论的关系和区别</h3><p>在英语中，舆情与舆论实际上是同一个词，即 public opinion。但在中国语境中，舆情与舆论之间既密不可分，又有着较为严格的区别。</p><p>舆情与舆论的主体都是民众群体，而这涉及的客体基本相同，都是政府整治、社会现象、公共事务等。同样具有丰富的政治、文化和心理内涵。而在发展阶段上，二者前后相继，舆情常为前导。舆情经过筛选、过滤和聚合，升华和提炼为舆论，而舆论又反过来对舆情产生作用。</p><p>舆情与舆论之间仍然有着非常明显的区别：</p><ol><li>表达主体：舆论的主体既可以是官方、媒体，也可以是民众，因此，常有 “官方舆论”、“媒体舆论”、与 “民间舆论” 之分，三者之间往往并不总是一致，有时甚至可能相互对立。</li><li>表现形态：舆论一般表现为言论，它可以是语言，也可以是文字。而舆情的表达形态显然更为丰富多样，既可以是语言文字，也可以是行为。</li><li>内涵：舆情包括意见、观点、态度、情绪，甚至部分行为也可以包含其中。而舆论作为舆情升华、提炼后的产物，主要是意见和观点。如果说舆情是混合物的话，那么舆论则相对纯净，成分较为单纯。</li><li>逻辑关系：一般来说，舆情形成在先，与此相对应的舆论形成在后，一些学者讲舆情称为潜舆论。</li></ol><p>舆情：纷繁多样、主流非主流、不稳定</p><p>舆论：相对稳定、主流、较单一</p><h3 id="各种效应的大致含义"><a class="anchor" href="#各种效应的大致含义">#</a> 各种效应的大致含义</h3><ol><li>羊群效应：从众心理，联合引导</li><li>蝴蝶效应：注重细节，舆情处置</li><li>风暴眼效应：不太类人群，舆情引导</li><li>沉锚效应：第一印象，舆情引导</li><li>近因效应：最近的印象影响较大，切忌虎头蛇尾</li><li>曝光效应：曝光越多，越易有影响力，舆情处置</li><li>骨牌效应：连锁反应，舆情预警</li></ol><p>沉默螺旋理论：来自于伊丽莎白・诺艾尔・诺依曼多年来发展并验证的民意理论，其核心是个人因害怕被群体和社会孤立，在表达意见前会预先估计民意的气候，当意识到自己的意见与大多数人相同时，便会在公众场合公开自己的观点，反之则会隐藏观点。这一趋势呈现螺旋的过程。</p><p>反沉默螺旋：是指在网络传播时代，受众的参与性大大提高，不再只是被动地接受信息，受众可以自由发表或支持 “少数” 意见，此种 “少数” 意见被更多的网民接受，可能发展为与 “多数” 意见势均力敌甚至超越和改变 “多数” 意见的情况。</p><h3 id="网络舆情的表达平台"><a class="anchor" href="#网络舆情的表达平台">#</a> 网络舆情的表达平台</h3><ul><li>BBS / 网络论坛</li><li>新闻跟帖</li><li>博客 / 播客</li><li>微博</li><li>即时通信群主题网站</li><li>以手机为代表的移动通信工具</li></ul><h3 id="网络舆情的表达方式"><a class="anchor" href="#网络舆情的表达方式">#</a> 网络舆情的表达方式</h3><ul><li>造词 / 造句</li><li>贴标签</li><li>人肉搜索</li><li>网络示威 / 爆吧</li><li>更换签名或头像</li><li>网络签名</li><li>网络恶搞 / 段子 / 表情</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章舆情分析概述&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#第一章舆情分析概述&quot;&gt;#&lt;/a&gt; 第一章：舆情分析概述&lt;/h1&gt;
&lt;h2 id=&quot;舆情与网络舆情&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#舆情与网络舆情&quot;&gt;#&lt;/a&gt; 舆情与网络舆</summary>
      
    
    
    
    <category term="计算机本科课程" scheme="https://osakana373.github.io/categories/Undergraduate-computer-course/"/>
    
    <category term="人工智能" scheme="https://osakana373.github.io/categories/Undergraduate-computer-course/AI/"/>
    
    <category term="舆情分析" scheme="https://osakana373.github.io/categories/Undergraduate-computer-course/AI/public-opinion-analysis/"/>
    
    
    <category term="计算机本科课程" scheme="https://osakana373.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>VAE-Stega-Reading-Report</title>
    <link href="https://osakana373.github.io/Undergraduate-computer-course/info-hiding/VAE-Stega-Reading-Report/"/>
    <id>https://osakana373.github.io/Undergraduate-computer-course/info-hiding/VAE-Stega-Reading-Report/</id>
    <published>2021-12-23T12:00:49.000Z</published>
    <updated>2021-12-23T14:54:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vae-stega基于变分自编码器的语言隐写技术"><a class="anchor" href="#vae-stega基于变分自编码器的语言隐写技术">#</a> VAE-Stega：基于变分自编码器的语言隐写技术</h1><h2 id="摘要"><a class="anchor" href="#摘要">#</a> 摘要</h2><p>近年来，基于文本自动生成技术的语言隐写技术得到了极大的发展，这是一个非常有前途的研究课题，但也是一个非常具有挑战性的研究课题。以往的工作主要集中在优化语言模型和条件概率编码方法，旨在生成质量更好的隐写句子。本文中报道了一些最新的实验结果，这似乎表明生成的隐写文本的质量不能完全保证其隐写文本的安全性，甚至具有显著的感知不可感知和统计不可感知冲突效应 (Psic 效应)。为了进一步提高生成的隐写文本的不可感知性和安全性，本文提出了一种新的基于变分自编码器 (VAE) 的语言隐写技术，可称为 VAE-Stega。我们使用 VAE-Stega 编码器学习大量正常文本的整体统计分布特征，然后使用解码器 VAE-Stega 生成隐写句子符合统计语言模型以及整体正常句子的统计分布，以保证生成的隐写的不可感知和统计不可感知文本。我们设计了几个实验来验证所提出的方法。实验结果表明，该模型可以大大提高生成的隐写句子的不可感知性，从而达到了最先进的性能。</p><h2 id="介绍"><a class="anchor" href="#介绍">#</a> 介绍</h2><p>从理论上讲，任何具有冗余信息空间的载体都可以用来隐藏内部的秘密信息，例如图像、视频、文本等。</p><p>Fridrich 总结说，一般隐写算法可分为三类：载体选择、载体修改和载体生成。基于载体生成的隐写术与其他两种方法的最大区别是：另外两种隐写方法将得到一个具有完全语义的载体，然后将秘密信息隐藏在里面。然而，基于载体生成的隐写方法需要自己生成载体。</p><p>两大挑战：</p><ol><li>如何自动生成一个语义完整、足够自然的信息载体</li><li>即使可以解决第一个挑战，如何进一步保证这些生成的隐写载体<br>的不可感知性</li></ol><p>本文将从理论分析、模型设计和实验结果等角度来回答这些问题。首先遵循 Cachin 对隐写算法安全性的分析，指出文本隐写的核心目标是尽可能减少正态文本和隐写文本之间的统计分布差异，如下图所示。</p><p><img data-src="fig1.jpg" alt="为了保证生成的隐写句子的不可感知性，隐写方法应尽量减少正常句子和隐写句子之间的总体统计分布差异"></p><p>其次，我们报告了我们最新的实验结果，这些结果表明，生成的隐写文本的质量并不完全等同于它们的不可感知性。为了进一步阐明<br>这两个概念之间的区别，我们将文本的不可感知性分别分为感知 - 不可感知性和统计 - 不可感知性两部分。第三，为了进一步提高生成的隐写文本的不可感知性，本文提出了一种基于变分自编码器 (VAE) 的语言隐写技术，可称为 VAE-Stega。利用 VAE-Stega 中的编码器学习正常文本的总体统计分布特征，然后利用 VAE-Stega 中的解码器生成符合统计语言模型和总体统计分布的隐写句子，从而保证生成的隐写文本的感知不可感知性和统计不可感知性，从而提高整个秘密通信处理的安全性。</p><h2 id="相关工作"><a class="anchor" href="#相关工作">#</a> 相关工作</h2><p>目前，大多数的隐写文本自动生成模型在以下框架下：使用一个精心设计的模型学习统计语言模型从大量的正常句子，然后实现秘密信息隐藏通过编码的条件每个词的概率分布在文本生成过程。在此框架中，早期的工作主要使用马尔可夫模型来近似语言模型，并计算每个单词、的条件概率分布。然而，由于马尔可夫模型本身的局限性，马尔可夫模型生成的文本质量仍然不够好，因此很容易被识别。近年来，随着自然语言处理技术的发展，越来越多的基于神经网络模型的隐写文本生成模型出现了。首先将字典划分，对每个单词进行固定编码，然后使用递归神经网络 (RNN) 学习自然文本的统计语言模型。最后，在文本生成过程中，根据需要隐藏的信息在每一步选择不同的单词作为输出。本文中将编码过程改为基于条件概率分布的动态编码，提出使用完整的二叉树或霍夫曼树对每个单词的条件概率进行固定长编码 (FLC) 或变长编码 (VLC)，并根据需要隐藏的秘密信息输出相应的单词，实现隐藏信息在句子生成过程中的嵌入。随后进一步提出了一种改进的编码算法称为 patient-Huffman，利用每个单词的条件概率分布的差异 (KL) 生成过程中动态调整每个单词的嵌入率，进一步提高生成的隐写文本的质量。</p><p>这些基于神经网络的文本自动生成方法比马尔可夫模型能更好地拟合正常句子的统计语言模型，从而显著提高了生成的隐写文本的质量。但最新的实验结果表明，这些方法只能解决第一个挑战，即自动生成语义完整和足够自然的隐写句子。</p><h2 id="psic效应"><a class="anchor" href="#psic效应">#</a> Psic 效应</h2><p>以往基于神经网络的隐写文本生成模型旨在尽可能多地生成具有最优条件概率的单词序列。这一优化目标只能保证生成的高质量的隐写文本。但是生成的隐写句子的质量越好，它们的不可感知性是否优秀存疑，因此本文做了一些实验来验证这个猜想。</p><p>首先，我们在 IMDB 数据集上训练 RNN-Stega 模型，然后使用训练后的 RNN-Stega 模型在每个不同的嵌入速率下生成 1000 个隐写句子。其次，我们计算了这些生成的隐写句子在不同嵌入率下的平均复杂度。在自然语言处理领域，困惑度 (perplexity) 是语言模型测试的标准度量。通常，困惑度值越小，生成的句子的语言模型越好。第三，我们混合了不同嵌入率的句子，然后我们严格遵循双盲实验的要求并邀请 11 名经过英语表达和阅读能力筛选的人对这些句子的质量进行评分（1-5 分，越高越好）。我们计算了这些生成的隐写句子在不同嵌入率下的平均人类得分，这可以代表这些生成的句子的主观质量。最后，我们将不同嵌入率的隐写句子与相同数量的正常句子混合，然后使用最近提出的文本隐分析模型进行检测。我们重复了这个实验 10 次，记录不同嵌入率下的检测精度的平均值和标准偏差。实验结果 1 如下图所示，其中横坐标表示每个单词中嵌入的比特的平均数量 (bpw)。橙色的线表示这些生成的隐写句子中计算出的平均困惑度（越小越好）。点的大小和透明度代表了人类的平均得分（越大越好）。蓝线表示不同嵌入率下的隐写检测精度（越低越好）。</p><p><img data-src="fig2.jpg" alt="RNN-Stega所面临的Psic效应。可以看出，随着嵌入率的提高，RNN-Stega生成的隐写文本质量逐渐下降，但其反步分析能力逐渐提高。我们将这种感知-不可感知和统计-不可感知的冲突现象称为感知-统计-不可感知冲突效应(Psic效应)"></p><p>根据上图，我们可以得出以下结论。首先，随着嵌入率的增加，生成的隐写句子的困惑度趋势和人的得分是一致的，它们都表明生成的隐写句子的质量在下降。同时，我们发现生成的隐写句子的质量并不等同于它们的不可感知性。当 bpw 小于 2 时生成的隐写句子质量最好，但最容易发现；当 bpw 在 5 左右时，生成的隐写句子质量最差，但其抵抗隐分析的能力最强。第三，我们注意到一个非常不寻常的现象：随着嵌入率的增加，隐写检测的准确性逐渐降低，这意味着生成的隐写句子更加难以检测。</p><p>在最近的一个预印本中也报告了类似的实验结果。实验表明，随着嵌入率的增加，生成的隐写句子与正常句子的条件概率分布的 KL 散度逐渐减小（越低越好），但人类评价得分也逐渐减小。这种现象似乎与我们通常的认知方式有所不同。一般来说，我们认为随着嵌入在载体中的附加信息量的增加，载体的不可感知性将会降低，这将反映在隐写分析精度的提高上。为了进一步解释这一异常现象，我们进行了更深入的实验分析。我们计算了每个生成的隐写句子在不同嵌入率下的困惑度，并进行了比较与正常句子的分布情况相同。结果如下图所示：</p><p><img data-src="fig3.jpg" alt="黑线表示正常句子的分布，其他颜色的线表示由RNN-Stega模型生成的具有不同嵌入率的隐写文本"></p><p>上图可以很好地解释小节 Pisc 小节中的现象。公共社交网络上的文本是由不同年龄和背景的人以不同的表达方式编写的句子。这就导致了大多数人类所写的事实句子可能不服从最优语言模型，形成较大的方差。之前的自动文本生成隐写模型主要侧重于优化每个单词的条件概率分布的语言模型和编码方法，主要解决第一个挑战。</p><p>随着嵌入率的提高，生成的隐写载体的质量和反隐写分析能力的不同趋势代表了这些生成的隐写载体的两个不同方面，我们将它们命名为感知 - 不可感知性和统计 - 不可感知性，如下图所示。感知不可感知性衡量的是生成的隐写载体的质量，而统计不可感知性衡量的是生成的隐写载体与正常载体之间的统计不可分性。</p><p><img data-src="fig4.jpg" alt="生成的隐写载体的不可感知性由两部分组成：感知不可感知性，表示每个单独生成的载体的质量，以及统计不可感知性，表示生成的载体与普通载体在统计上不可分割"></p><h2 id="ts-vae-methodology"><a class="anchor" href="#ts-vae-methodology">#</a> TS-VAE METHODOLOGY</h2><h3 id="变分自动编码器的结构"><a class="anchor" href="#变分自动编码器的结构">#</a> 变分自动编码器的结构</h3><p>一个变分的自动编码器符合一般的自动编码器架构，它通常是映射的单个样本 x 通过编码器到一个特征空间 z∈Z，然后使用解码器将该特征重构为一个原始样本，即：</p><p><img data-src="fig4.png" alt></p><p>然后，通过最小化重建的样本 x' 与原始样本 x 之间的差值，我们可以得到从样本空间到特征空间的最优映射。然而，自动编码器只学习样本与特征之间的点对点映射，因此解码器只能重建原始样本，而不能生成新的样本。由于统计不可感知性要求生成的隐写句子与正态句子的统计分布足够接近，因此我们的基本思想是找到一个编码函数，将正态句子嵌入到一个潜在空间 Z 中，形成 Pz 分布。然后，我们可以根据潜在空间的分布进行随机采样，得到一个采样的潜在向量 z。我们将这个向量 z 发送到解码器中，然后在 z 的约束下生成一个句子，从而保持生成的句子的分布与正常句子的分布一致。</p><p><img data-src="fig5.png" alt><br><img data-src="fig6.png" alt></p><h3 id="encoder-in-vae-stega"><a class="anchor" href="#encoder-in-vae-stega">#</a> Encoder in VAE-Stega</h3><p>在 VAE 架构中，任何模型都可以作为编码器使用，只要它可以提取输入句子的特征表达式并将其映射到特征空间 Z。在本文中，我们设计并比较了两种不同的编码器，其中一种他们使用一个以 LSTM 单元作为编码器的递归神经网络，我们称之为 VAE-Stega (LSTM-LSTM)。另一种是使用来自变压器 (BERT) 的双向编码器表示作为编码器，我们称之为 VAE-Stega (bertlstm)。</p><p>VAEStega (bertlstm) 结构如下图所示：</p><p><img data-src="fig7.jpg" alt="我们使用VAE-Stega编码器学习大量的正常句子的统计分布特征，然后使用解码器VAE-Stega生成隐写句子符合统计语言模型以及正常句子的总体统计分布，以保证生成的感知不可感知和统计不可感知文本"></p><h3 id="decoder-in-vae-stega"><a class="anchor" href="#decoder-in-vae-stega">#</a> Decoder in VAE-Stega</h3><p>RNN 可以从大量的正常文本中学习统计语言模型，然后根据之前生成的单词计算下一个单词的条件概率分布，最后可以生成符合该统计语言模型的句子。</p><p>对于 VAE-Stega (LSTM-LSTM)，它与 VAEStega (bertlstm) 共享相同的模型结构和相同的解码器，唯一的区别是编码器模块。VAE-Stega (LSTM-LSTM) 使用了一个以 LSTM 单元为编码器的递归神经网络。它使用最后一个时间步中最后一个隐藏层的输出作为输入句子的特征表达式。因此，对于 VAE-Stega (LSTM-LSTM)，我们只需要用以下形式替换公式：</p><p><img data-src="fig8.png" alt></p><p>其中，l 表示 VAE-Stega (LSTM-LSTM) 编码器中的隐藏层数。提取输入句子的特征表达式后，后续操作与上述 VAEStega (BERT-LSTM) 完全一致。</p><h3 id="信息的隐藏和提取"><a class="anchor" href="#信息的隐藏和提取">#</a> 信息的隐藏和提取</h3><p>与之前的隐写文本生成算法，如 RNN-Stega 模型相比，所提出的 VAE-Stega 模型在译码每个隐写句子的过程中，需要使用从潜在空间采样的相同的潜在向量。在实际使用中，由于计算机只能生成伪随机数，发送方和接收方只需要共享随机种子生成算法，以确保采样的潜在向量同步，从而确保在接收到的隐写文本中正确提取秘密信息。在每个时间步长中，Bob 将每个单词输入到相同的训练模型中，并得到下一个单词的条件概率分布。他首先将字典中的所有单词按概率降序排序，并选择顶部的 m 个单词形成候选池。然后，他使用与发送者相同的编码方法对候选池进行编码，如霍夫曼编码或算术编码。最后，根据当前时刻的实际传输字，接收器能够成功、准确地解码每个字中嵌入的位，从而完成隐蔽通信。</p><h2 id="实验和分析"><a class="anchor" href="#实验和分析">#</a> 实验和分析</h2><p>在本节中，我们进行了几个实验来测试所提出的 VAE-Stega 模型的性能。首先，我们介绍了我们在实验中使用的数据集，以及模型设置和训练细节。然后，我们主要分析了该模型生成的隐写句子的不可感知性。</p><h3 id="数据准备和模型训练"><a class="anchor" href="#数据准备和模型训练">#</a> 数据准备和模型训练</h3><p>在这项工作中，我们使用了两个大规模的公共文本数据集来训练我们的模型，它们分别是推特和 IMDB 电影评论。预处理后，包括将所有单词转换成小写，删除特殊符号，表情符号，web 链接和过滤低频单词，推特数据集包含 2639083 正常句子字典大小为 44856，IMDB 数据集包含总共 1282804 正常句子字典大小为 48042。VAE-Stega 模型中几乎所有的参数都可以通过训练得到，但仍有一些超参数需要确定。</p><p>通过多次比较实验，将这些超参数最终设置如下。对于解码器，我们使用与 RNN-Stega 相同的设置来生成句子，即我们将 LSTM 隐藏层数设置为 3 个，每一层包含 800 个 LSTM 单位。我们使用了 BERTbase 作为 VAE-Stega (BERT-LSTM) 中的编码器，其中包含 12 个 Transformer 块，隐藏大小 768，自注意头 12 个。我们将潜在空间的维数 (dimension of latent space) 设为 13，高速公路层数 (Highway layers) 为 2，隐藏维数为 1600。对于 VAE-Stega (LSTM-LSTM) 模型中的编码器，我们将其设置为与解码器相同。字典中的每个单词都被映射到一个 353 维的向量，我们使用 tanh 作为非线性激活函数。</p><p>神经网络的所有参数都需要通过训练来获得。在训练过程中，我们使用反向传播算法更新网络参数。通过最小化损失函数，我们希望所提出的模型能够同时学习正常句子的统计语言模型及其整体分布模式。在模型训练过程中，我们采用了 KL 代价退火策略，使模型能够更好地考虑语言模型和总体统计分布约束，使得解码器生成的隐写句子具有较高的感知不可感知性和统计不可感知性。</p><p><img data-src="fig9.jpg" alt="在模型训练过程中，损失树随着迭代步骤的变化而变化"></p><h3 id="不可感知分析"><a class="anchor" href="#不可感知分析">#</a> 不可感知分析</h3><p>为了测量所提出的 VAE-Stega 模型生成的隐写句子的不可感知性，根据之前的分析，我们需要对生成的隐写句子的语言模型进行测试，以困惑度 (ppl) 来衡量；另一方面，我们需要测试生成的隐写句子与正常句子的总体分布的差异，后者用 KLD 和 JSD 来测量。</p><p><img data-src="fig10.png" alt></p><p>具体测试表格见论文表一表二。这里仅说明结论。</p><p>根据表一所示的结果，我们可以得出以下结论。首先，我们在第三节 Psic 效应分析，之前的模型的优化目标，如 RNN-Stega，是确保生成的条件概率的每个单词的句子尽可能高，从而使生成隐写句子的质量尽可能好。最终结果表明，所生成的隐写句子具有较低的困惑度值。但如 MP、KLD 和 JSD 的计算结果所示，它们与正常句子的总体统计分布存在巨大差异。其次，我们发现，在文本生成过程中，对条件概率分布使用算术编码可以减少在单词的条件概率分布与霍夫曼编码的比较中生成的隐写文本和普通文本之间的差异。然而，通过比较 RNN-Stega (HC) 和 RNN-Stega (AC) 的 KLD 和 JSD，因为它们对文本的总体统计分布缺乏约束，这两种编码方法生成的隐写文本与正常文本的总体统计分布仍有很大的差异（算术编码略优于霍夫曼编码）。第三，我们发现，我们引入 VAE 架构后，模型因此可以学习正常文本的整体统计分布特征和进一步约束生成的隐写文本在一定程度上，这可以显著减少生成的隐写句子和正常的句子的总体统计分布的差异，极大地提高了统计的不可感知性，在稍微失去困惑的情况下（不大，它不会显著影响生成的隐写句子的感知不可感知性）。</p><h3 id="抗隐写分析能力"><a class="anchor" href="#抗隐写分析能力">#</a> 抗隐写分析能力</h3><p>我们使用最新的隐写分析模型检测 VAE-Stega 模型和 RNN-Stega<br> 模型在不同条件概率编码方法 (霍夫曼编码 (表 1) 和算术编码 (表 2) 下生成的隐写句子。我们使用在分类任务中常用的几个评估指标来评估我们的模型的性能，即准确率 (Acc) 和召回率 (R)。</p><p><img data-src="fig11.png" alt></p><p>TP 表示被模型预测为正的正样本的数量，FP 表示预测为正的负样本数量，FN 表示预测为负的正样本数量，TN 表示预测为负的负样本数量。</p><p><img data-src="table1.jpg" alt="由每个模型（使用隐霍夫曼编码）产生的隐写句子的抵抗能力"><br><img data-src="table2.jpg" alt="由每个模型（使用算术编码）产生的隐写句子的抵抗能力"></p><p>从表一表二结果中，我们可以得出以下结论。</p><ol><li>首先，虽然提出的 VAE-Stega 模型和 RNN-Stega 模型在隐写句子生成、条件概率编码和秘密信息隐藏等方面是一致的，但我们在隐写句子生成过程中考虑了正常句子的总体统计分布特征，大大提高了 VAE-Stega 生成的隐写句子的统计不可感知性，也大大提高了其抗隐写分析的能力。</li><li>其次，表一表二的结果再次证实了 Psic 效应，即随着嵌入率的提高，不同模型在不同数据集中生成的隐写分析文本的检测精度逐渐降低。然而，值得注意的是，我们认为这是当前隐写文本生成方法框架的独特现象：使用一个设计良好的模型来从大量的正常句子学习统计语言模型，然后实现秘密信息隐藏通过编码的条件概率分布的文本生成过程。这种方法在生成每个单词时截断了它们的条件概率。随着嵌入率的增加，截断的条件概率分布逐渐接近真实分布，因此生成的隐写文本中每个单词的条件概率分布的差逐渐接近正常句子的差。虽然这种现象可能很特殊，但我们认为它应该被视为这种隐写策略的一个特征，而不是一种缺点。毕竟，在实际使用方面，我们确实希望当嵌入率相对较大时，我们仍然能保持相对较小的隐写检测精度。</li><li>此外，需要注意的是，表一、表二中的一些结果似乎表明，VAEStega (bertlstm) 的性能比 VAE-Stega (LSTM-LSTM) 更差。这并不意味着我们认为 BERT 的特征提取能力低于 LSTM。实际上，这是因为我们直接使用了已经发布的训练过的 BERT 模型。它已经对我们的其他数据集进行了预训练，这可能会影响其性能。但是 VAE-Stega (LSTM-LSTM) 是从头开始训练的，所以 VAE-Stega (LSTM-LSTM) 的编码器和解码器使用相同的单词嵌入空间。</li></ol><h2 id="结论"><a class="anchor" href="#结论">#</a> 结论</h2><p>两大挑战：</p><ol><li>如何自动生成一个语义完整、足够自然的信息载体</li><li>即使可以解决第一个挑战，如何进一步保证这些生成的隐写载体的不可感知性</li></ol><p>解决第二个挑战，本文提出了一种新的隐写法 VAE-Stega。我们使用编码器在 VAE-Stega 学习整体统计分布特征的大量正常的文本，然后使用解码器 VAE-Stega 生成隐写句子符合统计语言模型以及正常句子的整体统计分布，以平衡和优化两个方面的不可感知性的 Psic 效应的影响。实验结果表明，与以往的方法相比，该模型能大大提高生成的隐写句子的不可感知性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vae-stega基于变分自编码器的语言隐写技术&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#vae-stega基于变分自编码器的语言隐写技术&quot;&gt;#&lt;/a&gt; VAE-Stega：基于变分自编码器的语言隐写技术&lt;/h1&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a cla</summary>
      
    
    
    
    <category term="计算机本科课程" scheme="https://osakana373.github.io/categories/Undergraduate-computer-course/"/>
    
    <category term="信息隐藏技术" scheme="https://osakana373.github.io/categories/Undergraduate-computer-course/info-hiding/"/>
    
    
    <category term="计算机本科课程" scheme="https://osakana373.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ModpDES</title>
    <link href="https://osakana373.github.io/Undergraduate-computer-course/cryptography/ModpDES/"/>
    <id>https://osakana373.github.io/Undergraduate-computer-course/cryptography/ModpDES/</id>
    <published>2021-12-21T12:08:44.000Z</published>
    <updated>2021-12-21T12:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验目的"><a class="anchor" href="#实验目的">#</a> 实验目的</h1><p>设计并实现针对有限域的对称密码算法。在作业三的基础上，把明文、密文、密钥的取值范围从 ' 任意 64bit 数据 ' 改为 ' 从 0 到 p-1 之间的整数 '，其中 p 是一个小于 2^{64} 的素数。密文应在密文空间内均匀分布。</p><h1 id="modpdes算法设计"><a class="anchor" href="#modpdes算法设计">#</a> ModpDES 算法设计</h1><p>ModpDES 算法与 DES 算法一样，使用了 Feistel 结构，但是与之不同的是，由于需要将明文、密文、密钥空间改为 0 到 p-1 之间的整数，也就是我们不能够再使用原来 DES 算法中对明文的初始置换，48 位子密钥的生成和加密函数 f 等，例如 S 盒之类的矩阵我们也不能够使用，因为它们为 64bit 一组的数据设计的。因此，我们需要重新设计加密函数 f，同时抛弃初始置换等置换操作和 S 盒等混淆操作，仅仅保留 Feistel 结构进行 16 轮的迭代。</p><p>下面我们来对算法核心做一些说明：</p><h2 id="生成子密钥"><a class="anchor" href="#生成子密钥">#</a> 生成子密钥</h2><p>由于循环左移、置换选择等操作可能会导致模 p 的密钥变成大于 p 的数，因此我们这里仅仅使用一个表达式由密钥生成 16 个子密钥，这里定义为 uint32_t 类型：</p><p><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> sub_key[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generate_sub_key</span><span class="params">(<span class="keyword">uint32_t</span> key, <span class="keyword">uint32_t</span> subkey[], <span class="keyword">uint32_t</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> c = <span class="number">231</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        subkey[i] = (<span class="keyword">uint32_t</span>)(((<span class="keyword">uint64_t</span>)key * c) % p);</span><br><span class="line">        c = (c * c) % <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的子密钥生成根据 subkey = key * c % p，其中 c 是一个常数，为了确保每个子密钥各不相同，我们经历一次循环就将 c 的值改变，具体 c = (c * c) % 1000，这样就根据密钥生成了 16 个子密钥。</p><h2 id="加密函数f"><a class="anchor" href="#加密函数f">#</a> 加密函数 f</h2><p>加密函数是算法最核心的部分，它的作用是在第 i 次加密迭代中用子密钥 Ki 对 R_{i-1} 进行加密。我们抛弃原来 DES 加密函数的设计思想，将加密函数 f 定义为：</p><p>f(Right, RoundKey) = (Right^{-1} * C + RoundKey) mod p</p><p>其中，Right^{-1} 为每次加密迭代中右部模 p 的乘法逆元，对于如何求解乘法逆元的问题，这里采用了费马小定理求取乘法逆元（具体介绍可见<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcG9wb2R5bmFzdHkvcC8xMzgyNDYxMC5odG1s">费马小定理求逆元</span>）。求取逆元的函数如下：</p><p><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">inverse_R</span><span class="params">(<span class="keyword">uint64_t</span> base, <span class="keyword">uint64_t</span> idx, <span class="keyword">uint64_t</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (idx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ans *= base;</span><br><span class="line">            ans %= p;</span><br><span class="line">        &#125;</span><br><span class="line">        base *= base;</span><br><span class="line">        base %= p;</span><br><span class="line">        idx &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 base 为右部，idx 为 p-2。</p><p>根据加密函数的定义，构造如下加密函数：</p><p><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">encrypt_f</span><span class="params">(<span class="keyword">uint64_t</span> R, <span class="keyword">uint32_t</span> p, <span class="keyword">uint32_t</span> sub_key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//求R的逆元</span></span><br><span class="line">    <span class="keyword">uint64_t</span> R_inv = inverse_R(R, (<span class="keyword">uint64_t</span>)p - <span class="number">2</span>, (<span class="keyword">uint64_t</span>)p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint64_t</span> c = <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">return</span> (R_inv * c + sub_key) % (<span class="keyword">uint64_t</span>)p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中常数 C 设为了 21，当然也可以设成任何值。</p><h2 id="加密过程"><a class="anchor" href="#加密过程">#</a> 加密过程</h2><p>加密过程会进行 16 加密迭代。首先将明文 m 分为左右两部：L = m /p, R = m % p，这样就将明文分成了左右两部分，且这两部分均为 mod p 的，因为明文 mod p^2；然后进入 16 轮的循环中，将右部和子密钥送入加密函数 f 中进行计算，然后计算新的 R = (L + f) % p，最后将 L = 原来的右部；循环加密迭代结束后，返回密文，其中密文等于 R * p + L</p><p>代码实现如下：<br><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">encrypt</span><span class="params">(<span class="keyword">uint64_t</span> input, <span class="keyword">uint32_t</span> p, <span class="keyword">uint32_t</span> subkey[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> L = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">    L = input / p;</span><br><span class="line">    R = input % p;</span><br><span class="line">    <span class="keyword">uint64_t</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        f = encrypt_f(R, p, subkey[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">uint64_t</span> tmp = R;</span><br><span class="line">        R = (L + f) % (<span class="keyword">uint64_t</span>)p;</span><br><span class="line">        L = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R * (<span class="keyword">uint64_t</span>)p + L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>加密过程的结构如下（仅展示第一次解密迭代过程，后续过程相同）：</p><p><img data-src="modeDES.png" alt></p><h2 id="解密过程"><a class="anchor" href="#解密过程">#</a> 解密过程</h2><p>解密过程几乎与加密过程类似，只是在解密的时候计算右部并未是 R = (L + f) % p，而是 R = (L - f) % p，从而实现了加解密可逆；而子密钥的使用顺序与加密过程相反。代码实现如下：</p><p><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">decrypt</span><span class="params">(<span class="keyword">uint64_t</span> cipherText, <span class="keyword">uint32_t</span> p, <span class="keyword">uint32_t</span> subkey[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> L = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">    L = cipherText / p;</span><br><span class="line">    R = cipherText % p;</span><br><span class="line">    <span class="keyword">uint64_t</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        f = encrypt_f(R, p, subkey[<span class="number">15</span> - i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">uint64_t</span> tmp = R;</span><br><span class="line">        <span class="keyword">if</span> (L &lt; f) &#123;</span><br><span class="line">            R = (L + p - f) % (<span class="keyword">uint64_t</span>)p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            R = (L - f) % (<span class="keyword">uint64_t</span>)p;</span><br><span class="line">        &#125;</span><br><span class="line">        L = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R * (<span class="keyword">uint64_t</span>)p + L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="实验结果分析"><a class="anchor" href="#实验结果分析">#</a> 实验结果分析</h1><p>我们将明文设为 289673124，密钥设为 26372，p 设为 49993（素数），测试加解密一百万次花费的时间，得到如下结果：</p><p><img data-src="result1.png" alt></p><p>可以看出，明文和密文都是模 p^2 的数，加解密一百万次仅耗时 11886 毫秒，速度很快。</p><p>下面我们测试一下较大 p 和较小 p 的情况：<br><img data-src="result2.png" alt><br><img data-src="result3.png" alt></p><p>可以看出，加解密过程正确，且明文和密文空间均模 p^2，满足要求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实验目的&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#实验目的&quot;&gt;#&lt;/a&gt; 实验目的&lt;/h1&gt;
&lt;p&gt;设计并实现针对有限域的对称密码算法。在作业三的基础上，把明文、密文、密钥的取值范围从 &#39; 任意 64bit 数据 &#39; 改为 &#39; 从 0 到 p-1 之间</summary>
      
    
    
    
    <category term="计算机本科课程" scheme="https://osakana373.github.io/categories/Undergraduate-computer-course/"/>
    
    <category term="密码学" scheme="https://osakana373.github.io/categories/Undergraduate-computer-course/cryptography/"/>
    
    
    <category term="计算机本科课程" scheme="https://osakana373.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ES6新特性</title>
    <link href="https://osakana373.github.io/Front-EndDevelopment/ES6/ES6%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://osakana373.github.io/Front-EndDevelopment/ES6/ES6%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2021-12-12T08:34:14.000Z</published>
    <updated>2021-12-15T08:22:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a class="anchor" href="#基础语法">#</a> 基础语法</h1><h2 id="let"><a class="anchor" href="#let">#</a> let</h2><ol><li>变量不能重复声明</li><li>let 是块级作用域，位于代码块中，代码块外没有定义</li><li>不存在变量提升，初始不会对 let 定义的变量进行收集，赋予 undefined 初值</li><li>不影响作用域链，如果在代码块中调用了函数，如果在该函数中找不到变量定义，则会到上一级，也就是块级作用域中找到 let 定义的变量</li></ol><h2 id="const"><a class="anchor" href="#const">#</a> const</h2><ol><li>const 用来声明常量，一定要赋初值</li><li>值一旦被确定就不能修改，且一般变量名使用大写</li><li>也是一个块级作用域</li><li>对于数组和对象的元素修改，不算做对常量的修改，不会报错，是因为常量所指向的起始地址没有发生改变。<br><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TEAM = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">TEAM.push(<span class="string">&#x27;e&#x27;</span>);</span><br></pre></td></tr></table></figure><br> 上面的代码不会报错，但下面的代码就会报错：<br><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TEAM = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="解构赋值"><a class="anchor" href="#解构赋值">#</a> 解构赋值</h2><p>解构赋值：允许按照一定模式从数组和对象中提取值，对变量进行赋值。</p><ol><li>数组的解构<br> <figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> F4 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> [a, b, c, d] = F4;</span><br></pre></td></tr></table></figure></li><li>对象的解构<br> <figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;osakana&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="string">&#x27;20&#x27;</span>,</span><br><span class="line">    <span class="attr">click</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;name, age, click&#125; = a;</span><br><span class="line">click();</span><br></pre></td></tr></table></figure><br> 执行如上代码就会在控制台输出 hello</li></ol><h2 id="模板字符串"><a class="anchor" href="#模板字符串">#</a> 模板字符串</h2><p>ES6 引入新的声明字符串的方式：反单引号 (``)</p><ol><li>内容中可以直接出现换行符，而普通的引号不能</li><li>变量拼接<br> <figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> love = <span class="string">&#x27;czj&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> out = <span class="string">`<span class="subst">$&#123;love&#125;</span>是我最爱的女孩!`</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="箭头函数"><a class="anchor" href="#箭头函数">#</a> 箭头函数</h2><p>ES6 允许使用箭头 (=&gt;) 定义函数<br> <figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个函数</span></span><br><span class="line"><span class="comment">// let fn = function()&#123;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><br> 箭头函数的特性：</p><ol><li>this 是静态的，this 始终指向函数声明时所在作用域下的 this 的值</li><li>不能作为构造函数实例化对象</li><li>不能使用 arguments 变量（用来保存实参）</li><li>箭头函数的简写<ol><li>省略小括号，当形参有且只有一个时<br> <figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n + n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>省略花括号，当代码体只有一条语句时，此时 return 必须省略，语句的执行结果就是函数的返回值<br> <figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pow = <span class="function">(<span class="params">n</span>) =&gt;</span> n*n;</span><br></pre></td></tr></table></figure></li></ol></li><li>箭头函数适合与 this 无关的回调、定时器，数组的方法回调；不适合与 this 有关的回调、事件回调、对象的方法</li></ol><h2 id="rest参数"><a class="anchor" href="#rest参数">#</a> rest 参数</h2><p>ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments<br><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">date</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line">date(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure><br> 上面的代码会返回一个数组 ['a','b','c']，rest 参数必须要放到参数最后<br> <figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">date</span>(<span class="params">a,b,...args</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="扩展运算符"><a class="anchor" href="#扩展运算符">#</a> 扩展运算符</h2><p>[...] 扩展运算符能将数组转换为逗号分隔的参数序列</p><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个数组</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>]; <span class="comment">//=&gt; &#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;</span></span><br><span class="line"><span class="comment">//声明一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hanshu</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">hanshu(...array); <span class="comment">//hanshu(&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;)</span></span><br></pre></td></tr></table></figure></p><h2 id="symbol"><a class="anchor" href="#symbol">#</a> Symbol</h2><p>Symbol 是一种 ES6 新引入的原始数据类型，表示独一无二的值。类似于字符串的数据类型。</p><p>Symbol 特点：</p><ol><li>值唯一，用来解决命名冲突的问题</li><li>值不能与其他数据进行运算</li><li>定义的对象属性不能使用 for...in 循环遍历，但是可以使用 Reflect.ownKeys 来获取对象的所有键名</li></ol><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s4 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s3 === s4) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>Symbol 可以用来向对象中添加方法</p><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设我们不知道对象中有哪些属性</span></span><br><span class="line"><span class="keyword">let</span> game = &#123;···&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个对象</span></span><br><span class="line"><span class="keyword">let</span> methods = &#123;</span><br><span class="line">    <span class="attr">up</span>: <span class="built_in">Symbol</span>(),</span><br><span class="line">    <span class="attr">down</span>: <span class="built_in">Symbol</span>()</span><br><span class="line">&#125;;</span><br><span class="line">game[methods.up] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;up&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">game[methods.down] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;down&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种方式</span></span><br><span class="line"><span class="keyword">let</span> game = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;overwatch&quot;</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">&#x27;say&#x27;</span>)]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Symbol 还有 11 个内置属性，这里仅举个例子：<br><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](param)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(param);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(test <span class="keyword">instanceof</span> Person); <span class="comment">//会返回false</span></span><br></pre></td></tr></table></figure></p><h2 id="迭代器"><a class="anchor" href="#迭代器">#</a> 迭代器</h2><p>ES6 创造了一种新的遍历命令 for...of 循环，Iterator 接口主要供 for...of 消费。</p><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个数组</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 会输出 array 数组中的每个元素的值。</p><h3 id="迭代器的工作原理"><a class="anchor" href="#迭代器的工作原理">#</a> 迭代器的工作原理</h3><ol><li>创建一个指针对象，指向当前数据结构的起始位置</li><li>第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员</li><li>接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员</li><li>每调用 next 方法返回一个包含 value 和 done 属性的对象</li></ol><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义遍历数据</span></span><br><span class="line"><span class="keyword">const</span> osakana = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;osakana373&quot;</span>,</span><br><span class="line">    <span class="attr">stu</span>: [</span><br><span class="line">        <span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;xiaowang&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;xiaozhang&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(index &lt; _this.stu.length) &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = &#123;<span class="attr">value</span>: _this.stu[index], <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">                    index++;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> osakana) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 上面的代码会输出 stu 数组中的每一个元素。</p><h2 id="生成器"><a class="anchor" href="#生成器">#</a> 生成器</h2><p>生成器是一个特殊函数，用来进行异步编程，格式如下：</p><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加一个*号</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let iterator = gen();</span></span><br><span class="line"><span class="comment">// iterator.next();</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> gen())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 只有调用迭代器的 next 方法才会打印 hello，或者使用 for...of 语句遍历。生成器也可以传参。</p><h1 id="promise"><a class="anchor" href="#promise">#</a> Promise</h1><p>Promise 是 ES6 引入的异步编程的新解决方案，语法上是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。</p><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化Promise</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="string">&#x27;数据库数据&#x27;</span>,</span><br><span class="line">        <span class="comment">//resolve</span></span><br><span class="line">        resolve(data);</span><br><span class="line">        <span class="comment">//reject(err)</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用promise对象的then方法</span></span><br><span class="line"><span class="comment">//value 成功 ；reason 失败</span></span><br><span class="line"><span class="comment">//只要上面调用了resolve（成功），就执行then方法中的第一个回调函数；调用reject（失败），就执行第二个回调函数</span></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="promise读取文件"><a class="anchor" href="#promise读取文件">#</a> Promise 读取文件</h2><p>这里用到了一些 node.js 的知识（详情可以看<span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9ub2RlanMvbm9kZWpzLWZzLmh0bWw=">菜鸟教程 Node.js</span>)，不过不会问题也不大。</p><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入fs模块（node.js中的知识）</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//调用方法读取文件</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;./xxx/xxx&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//如果失败，则抛出错误</span></span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="comment">//没有错误，则输出内容</span></span><br><span class="line">    <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">    <span class="comment">//data就是文件中的内容</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Promise封装</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;./xxx/xxx&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//如果失败，则抛出错误</span></span><br><span class="line">        <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">        <span class="comment">//如果成功，则输出内容</span></span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value.toString());</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;读取失败&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="promise封装ajax请求"><a class="anchor" href="#promise封装ajax请求">#</a> Promise 封装 AJAX 请求</h2><p>我们假设接口地址为：<span class="exturl" data-url="aHR0cHM6Ly9hcGkuYXBpb3Blbi50b3AvZ2V0Sm9rZQ==">https://api.apiopen.top/getJoke</span></p><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装Promise</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//1. 创建对象</span></span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="comment">//2. 初始化</span></span><br><span class="line">    xhr.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://api.apiopen.top/getJoke&quot;</span>);</span><br><span class="line">    <span class="comment">//3. 发送</span></span><br><span class="line">    xhr.send();</span><br><span class="line">    <span class="comment">//4. 绑定事件，处理相应结果</span></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span>(xhr.onreadystatechange === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="comment">//判断响应状态码 200-299 表示成功</span></span><br><span class="line">            <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                <span class="comment">//表示成功</span></span><br><span class="line">                <span class="comment">// console.log(xhr.response);</span></span><br><span class="line">                resolve(xhr.response);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//表示失败</span></span><br><span class="line">                <span class="comment">// console.error(xhr.status);</span></span><br><span class="line">                reject(xhr.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定回调</span></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="promiseprototypethen方法"><a class="anchor" href="#promiseprototypethen方法">#</a> Promise.prototype.then 方法</h2><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;用户数据&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//then方法返回结果也是一个promise对象，对象状态由回调函数执行的结果决定</span></span><br><span class="line"><span class="keyword">const</span> result = p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value.toString());</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;读取失败&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="catch方法"><a class="anchor" href="#catch方法">#</a> catch 方法</h2><p>catch 方法用来指定失败的回调</p><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        reject(<span class="string">&#x27;出错啦&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//不指定第一个参数，then和catch一样</span></span><br><span class="line">p.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h1 id="set"><a class="anchor" href="#set">#</a> Set</h1><p>ES6 提供了新的数据结构 Set（集合）。类似于数组，但成员的值都是唯一的，集合实现了 iterator 接口，故可使用扩展运算符合 for...of 进行遍历。</p><p>Set 的属性和方法：</p><ol><li>size  返回集合的元素个数</li><li>add   增加一个新元素，返回当前集合</li><li>delete 删除元素，返回 boolean 值</li><li>has   检测集合中是否包含某个元素，返回 boolean 值</li></ol><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"><span class="comment">//s1中的元素会自动去重</span></span><br><span class="line">s1.add(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">s1.delete(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">s1.has(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> s1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">//会打印s1中所有元素的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="map"><a class="anchor" href="#map">#</a> Map</h1><p>ES6 提供了 Map 数据结构，类似于对象，也是键值对的集合。但是 “键” 的范围不限于字符串，各种类型的值（包括对象）都可以当做键。Map 也实现了 iterator 接口，故可使用扩展运算符合 for...of 进行遍历。</p><p>Map 的属性和方法：</p><ol><li>size  返回 Map 的元素个数</li><li>set   增加一个新元素，返回当前 Map</li><li>get   返回键名对象的键值</li><li>has   检测 Map 中是否包含某个元素，返回 boolean 值</li><li>clear 清空集合，返回 undefined</li></ol><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明 Map</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">m.set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;osakana&#x27;</span>);</span><br><span class="line">m.set(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h1 id="class类"><a class="anchor" href="#class类">#</a> Class 类</h1><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5传统构造方法创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Phone</span>(<span class="params">brand, price</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Phone.prototype.call = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Huawei = <span class="keyword">new</span> Phone(<span class="string">&#x27;华为&#x27;</span>, <span class="number">4999</span>);</span><br><span class="line">Huawei.call();</span><br><span class="line"><span class="built_in">console</span>.log(Huawei);</span><br><span class="line"></span><br><span class="line"><span class="comment">//class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造方法，名字固定不能修改</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">brand, price</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法必须使用该语法，不能使用ES5的对象完整形式</span></span><br><span class="line">    <span class="function"><span class="title">call</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Huawei = <span class="keyword">new</span> Phone(<span class="string">&#x27;华为&#x27;</span>, <span class="number">4999</span>);</span><br></pre></td></tr></table></figure></p><h2 id="class类的静态成员"><a class="anchor" href="#class类的静态成员">#</a> class 类的静态成员</h2><p>类的静态成员属于这个类，不属于这个类的实例</p><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>= &#123;</span><br><span class="line">    <span class="comment">//静态属性</span></span><br><span class="line">    <span class="keyword">static</span> name = <span class="string">&#x27;手机&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">change</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Huawei = <span class="keyword">new</span> Phone();</span><br><span class="line"><span class="built_in">console</span>.log(Huawei.name); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Phone.name);  <span class="comment">//手机</span></span><br></pre></td></tr></table></figure></p><h1 id="构造函数继承"><a class="anchor" href="#构造函数继承">#</a> 构造函数继承</h1><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父级构造函数：手机</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Phone</span>(<span class="params">brand, price</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Phone.prototype.call = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子级构造函数：智能手机</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SmartPhone</span>(<span class="params">brand, price, color, size</span>) </span>&#123;</span><br><span class="line">    Phone.call(<span class="built_in">this</span>, brand, price); <span class="comment">//继承了父类的brand和price</span></span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置子级构造函数的原型（子级构造函数就会有父级构造函数的方法）</span></span><br><span class="line">SmartPhone.prototype = <span class="keyword">new</span> Phone;</span><br><span class="line">SmartPhone.prototype.constructor = SmartPhone; <span class="comment">//加不加都可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明子级构造函数的方法</span></span><br><span class="line">SmartPhone.prototype.photo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="keyword">const</span> Huawei = <span class="keyword">new</span> SmartPhone(<span class="string">&#x27;Huawei&#x27;</span>, <span class="number">4999</span>, <span class="string">&#x27;星河银&#x27;</span>, <span class="string">&#x27;6.7inch&#x27;</span>);</span><br></pre></td></tr></table></figure></p><h1 id="类继承"><a class="anchor" href="#类继承">#</a> 类继承</h1><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造方法，名字固定不能修改</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">brand, price</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法必须使用该语法，不能使用ES5的对象完整形式</span></span><br><span class="line">    <span class="function"><span class="title">call</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">brand, price, color, size</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(brand, price); <span class="comment">//类似Phone.call(this, brand, price);</span></span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">photo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        consolo.log();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子类对父类方法的重写</span></span><br><span class="line">    <span class="function"><span class="title">call</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="keyword">const</span> Huawei = <span class="keyword">new</span> SmartPhone(<span class="string">&#x27;Huawei&#x27;</span>, <span class="number">4999</span>, <span class="string">&#x27;星河银&#x27;</span>, <span class="string">&#x27;6.7inch&#x27;</span>);</span><br></pre></td></tr></table></figure></p><h2 id="class中的getter和setter设置"><a class="anchor" href="#class中的getter和setter设置">#</a> class 中的 getter 和 setter 设置</h2><p>get 和 set 通常对对象的动态属性进行封装。</p><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取price</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">price</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置price，必须要有一个参数</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title">price</span>(<span class="params">newVal</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="数值扩展"><a class="anchor" href="#数值扩展">#</a> 数值扩展</h1><ol><li>Number.EPSILON 是 js 表示的最小精度</li><li>二进制、八进制和十六进制：0bxxx 0oxxx 0xxxx</li><li>Number.isFinite () 检测一个数值是否为有限数</li><li>Number.isNaN () 检测一个数值是否为 NaN</li><li>Number.parseInt () 字符串转整数（会截断）</li><li>Number.isInteger () 判断一个数是否为整数</li><li>Math.trunc () 将数字的小数部分抹掉</li><li>Math.sugn () 判断一个数是否为正数负数还是 0（1,-1,0）</li></ol><h1 id="对象方法扩展"><a class="anchor" href="#对象方法扩展">#</a> 对象方法扩展</h1><ol><li><span class="exturl" data-url="aHR0cDovL09iamVjdC5pcw==">Object.is</span> (a, b) 判断两个值是否完全相等</li><li>Object.assign () 对象的合并，相同属性后面对象会覆盖前面对象</li><li>Object.setPrototypeOf (a, b) 设置原型对象，b 是 a 的原型对象</li><li>Object.getPrototypeOf 获取一个对象的原型对象</li><li>Object.keys () 获取对象所有的键</li><li>Object.values () 获取对象所有的值</li><li>Object.entries () 返回一个数组，数组中每个成员还是一个数组</li><li>Object.getOwnPropertyDescriptors () 获取对象属性的描述对象</li></ol><h1 id="es8新特性"><a class="anchor" href="#es8新特性">#</a> ES8 新特性</h1><h2 id="async和await"><a class="anchor" href="#async和await">#</a> async 和 await</h2><p>async 和 await 两种语法结合可以让异步代码像同步代码一样</p><h3 id="async函数"><a class="anchor" href="#async函数">#</a> async 函数</h3><ol><li>async 函数的返回值为 promise 对象</li><li>promise 对象的结果由 async 函数执行的返回值决定</li></ol><h3 id="await表达式"><a class="anchor" href="#await表达式">#</a> await 表达式</h3><ol><li>await 必须写在 async 函数中</li><li>await 右侧的表达式一般为 promise 对象</li><li>await 返回的是 promise 成功的值</li><li>await 的 promise 失败了，就会抛出异常，需要通过 try...catch 捕获处理</li></ol><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建promise对象</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;成功的值！&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> p;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><br> 上面的代码会输出 &quot;成功的值！&quot;</p><h3 id="async和await封装ajax请求"><a class="anchor" href="#async和await封装ajax请求">#</a> async 和 await 封装 AJAX 请求</h3><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送AJAX请求，返回的结果是Promise对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">senfAJAX</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="keyword">const</span> x = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        x.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">        <span class="comment">//发送</span></span><br><span class="line">        x.send();</span><br><span class="line">        <span class="comment">//事件绑定</span></span><br><span class="line">        x.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(x.status &gt;= <span class="number">200</span> &amp;&amp; x.statue &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                    resolve(x.response);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(x.status);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//promise then 方法测试</span></span><br><span class="line">sendAJAX(<span class="string">&quot;https://api.....&quot;</span>).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//async 与 await测试</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//发送AJAX请求</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> sendAJAX(<span class="string">&quot;https://api.....&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="es9新特性"><a class="anchor" href="#es9新特性">#</a> ES9 新特性</h1><h2 id="对象展开"><a class="anchor" href="#对象展开">#</a> 对象展开</h2><p>ES9 中为对象提供了像数组一样的 rest 参数和扩展运算符</p><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rest参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">&#123;host, port, ...user&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(host);</span><br><span class="line">    <span class="built_in">console</span>.log(port);</span><br><span class="line">    <span class="built_in">console</span>.log(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connect(&#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3306</span>,</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;root&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展运算符</span></span><br><span class="line"><span class="keyword">const</span> one = &#123;</span><br><span class="line">    <span class="attr">q</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> two = &#123;</span><br><span class="line">    <span class="attr">w</span>: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> three = &#123;</span><br><span class="line">    <span class="attr">e</span>: <span class="string">&#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> four = &#123;</span><br><span class="line">    <span class="attr">r</span>: <span class="string">&#x27;d&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把四个对象的属性放在一起，完成对象的合并</span></span><br><span class="line"><span class="keyword">const</span> result = &#123;...one, ...two, ...three, ...four&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础语法&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#基础语法&quot;&gt;#&lt;/a&gt; 基础语法&lt;/h1&gt;
&lt;h2 id=&quot;let&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#let&quot;&gt;#&lt;/a&gt; let&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;变量不能重复声明&lt;/li</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://osakana373.github.io/categories/JavaScript/"/>
    
    
    <category term="前端开发" scheme="https://osakana373.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之可执行文件篡改</title>
    <link href="https://osakana373.github.io/Undergraduate-computer-course/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%AF%A1%E6%94%B9/"/>
    <id>https://osakana373.github.io/Undergraduate-computer-course/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%AF%A1%E6%94%B9/</id>
    <published>2021-12-09T07:40:49.000Z</published>
    <updated>2021-12-20T09:11:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="elf文件格式"><a class="anchor" href="#elf文件格式">#</a> ELF 文件格式</h1><p><img data-src="ELF.png" alt></p><p>ELF 文件由 4 部分组成，分别是 ELF 头、程序头表、节和节头表。其中，只有 ELF 头的位置是固定的。</p><h2 id="elf-header"><a class="anchor" href="#elf-header">#</a> ELF Header</h2><p>ELF 头的格式定义如下：</p><p><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EI_NIDENT (16)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>e_ident[EI_NIDENT];<span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf32_Halfe_type;<span class="comment">/* Object file type */</span></span><br><span class="line">  Elf32_Halfe_machine;<span class="comment">/* Architecture */</span></span><br><span class="line">  Elf32_Worde_version;<span class="comment">/* Object file version */</span></span><br><span class="line">  Elf32_Addre_entry;<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf32_Offe_phoff;<span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf32_Offe_shoff;<span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf32_Worde_flags;<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf32_Halfe_ehsize;<span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf32_Halfe_phentsize;<span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf32_Halfe_phnum;<span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf32_Halfe_shentsize;<span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf32_Halfe_shnum;<span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf32_Halfe_shstrndx;<span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure></p><p>这里，我们仅关注几个我们需要用到的项：</p><ol><li>e_entry 程序的入口地址。</li><li>e_phoff 程序头表在文件中的偏移量（以字节计数）。这里的值是 0x34。</li><li>e_ehsize ELF 头的大小。这里的值为 0x34。</li></ol><h2 id="program-header-table"><a class="anchor" href="#program-header-table">#</a> Program Header Table</h2><p>程序头表的结构如下：</p><p><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Program segment header.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Wordp_type;<span class="comment">/* Segment type */</span></span><br><span class="line">  Elf32_Offp_offset;<span class="comment">/* Segment file offset */</span></span><br><span class="line">  Elf32_Addrp_vaddr;<span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf32_Addrp_paddr;<span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf32_Wordp_filesz;<span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf32_Wordp_memsz;<span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf32_Wordp_flags;<span class="comment">/* Segment flags */</span></span><br><span class="line">  Elf32_Wordp_align;<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure></p><p>程序头表描述的是系统准备程序运行所需的一个段或其他信息。我们关注以下几个项：</p><ol><li>p_offset 段的第一个字节在文件中的偏移。</li><li>p_vaddr 段的第一个字节在内存中的虚拟地址。</li><li>p_filesz 段在文件中的长度。</li><li>p_memsz 段在内存中的长度。</li></ol><h2 id="执行视图"><a class="anchor" href="#执行视图">#</a> 执行视图</h2><p><img data-src="ELFfile.png" alt="ELF文件中程序头表和节头表指向的区域"><br><img data-src="view.jpg" alt="ELF文件链接视图和执行视图对照"></p><p>上图左边为链接视图，主要指前面 ELF 头部的节头表定义的节区分布，它指明了目标代码文件的内容布局。</p><p>上图右边为执行视图，主要指前面 ELF 头部的程序头表定义的段区分布，它指明了程序运行时的内存布局。</p><h1 id="篡改流程"><a class="anchor" href="#篡改流程">#</a> 篡改流程</h1><h2 id="创建-elf头和程序头的结构体"><a class="anchor" href="#创建-elf头和程序头的结构体">#</a> 创建 ELF 头和程序头的结构体</h2><p>我们创建 ELF 头和程序头的结构体，用来存储相关的原始数据，并根据嵌入需要来更新结构体中的数据。</p><p><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Start inject code:\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> old_entry;  <span class="comment">//原始程序入口地址</span></span><br><span class="line"><span class="keyword">int</span> old_phsize; <span class="comment">//ELF头中存放的程序头表的偏移</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ELF Header Table struct</span></span><br><span class="line">Elf32_Ehdr elf_ehdr;</span><br><span class="line"><span class="comment">// Program Header Table struct </span></span><br><span class="line">Elf32_Phdr elf_phdr;</span><br></pre></td></tr></table></figure></p><h2 id="读取elf头的信息并存储"><a class="anchor" href="#读取elf头的信息并存储">#</a> 读取 ELF 头的信息并存储</h2><p>我们将 ELF 头信息赋值给 elf_ehdr 结构体，将入口地址赋值给 old_entry，为后面更改入口地址做准备。<br><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read elf</span></span><br><span class="line"><span class="keyword">int</span> old_file = open(elf_file, O_RDWR);</span><br><span class="line">read(old_file, &amp;elf_ehdr, <span class="keyword">sizeof</span>(elf_ehdr));</span><br><span class="line">old_entry = elf_ehdr.e_entry;</span><br></pre></td></tr></table></figure></p><h2 id="读取程序头表信息并存储"><a class="anchor" href="#读取程序头表信息并存储">#</a> 读取程序头表信息并存储</h2><p>我们先将 elf 头信息丢弃到 buffer 中（因为我们上一步已经存储了相关信息），然后读取程序头表信息并将其存进 elf_phdr 结构体中。<br><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read program head table    </span></span><br><span class="line">close(old_file);</span><br><span class="line">old_file = open(elf_file, O_RDWR);</span><br><span class="line">read(old_file, &amp;buffer , elf_ehdr.e_phoff);</span><br><span class="line">read(old_file, &amp;elf_phdr, <span class="keyword">sizeof</span>(elf_phdr));</span><br></pre></td></tr></table></figure></p><h2 id="更新程序入口地址"><a class="anchor" href="#更新程序入口地址">#</a> 更新程序入口地址</h2><p>我们将预期的入口地址设为程序头表第一项指向的段的后面（当然也可以新增一个节，找到空闲位置并将入口地址指向这个节区，这里做是为了方便）。e_entry = p_vaddr + p_filesz，p_vaddr 也就是第一个程序头表指向的段的第一个字节所在的地址，而 p_filesz 也就是程序头表指向的段的大小，因此两者相加就是指向程序头表指向的段之后的区域。<br><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// update new entry </span></span><br><span class="line">elf_ehdr.e_entry = elf_phdr.p_vaddr + elf_phdr.p_filesz;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;new entry: %x\n&quot;</span>, elf_ehdr.e_entry);</span><br></pre></td></tr></table></figure></p><h2 id="更新elf头"><a class="anchor" href="#更新elf头">#</a> 更新 ELF 头</h2><p>重新做 close 和 open 操作是为了重置 old_file 的值（也相当于指针），以便从头开始读取文件信息。</p><p>我们将前面已经更新信息后的 elf_ehdr 结构体数据写入可执行文件中，完成 ELF 头的更新。这里 old_phsize 计算的值是为了后面嵌入代码做的准备工作，也就是可执行文件开始到嵌入代码位置的偏移。</p><p>随后将第一个程序头表指向的段扩容，增加一页 (4k) 大小，以便存放我们嵌入的代码。<br><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//update ELF head</span></span><br><span class="line">close(old_file);</span><br><span class="line">old_file = open(elf_file, O_RDWR);</span><br><span class="line">write(old_file, &amp;elf_ehdr, <span class="keyword">sizeof</span>(elf_ehdr));</span><br><span class="line">old_phsize = elf_phdr.p_filesz + elf_phdr.p_offset;</span><br><span class="line">elf_phdr.p_filesz += PAGE_SIZE;</span><br><span class="line">elf_phdr.p_memsz += PAGE_SIZE;</span><br></pre></td></tr></table></figure></p><h2 id="更新程序头表"><a class="anchor" href="#更新程序头表">#</a> 更新程序头表</h2><p>将 elf_phdr 结构体写入可执行文件，完成程序头部表的更新。随后进入到嵌入代码函数 insert 中。<br><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// update program head table</span></span><br><span class="line">close(old_file);</span><br><span class="line">old_file = open(elf_file, O_RDWR);</span><br><span class="line">read(old_file, &amp;buffer, elf_ehdr.e_phoff);</span><br><span class="line">write(old_file, &amp;elf_phdr, <span class="keyword">sizeof</span>(elf_phdr));</span><br><span class="line">insert(elf_ehdr, old_file, old_entry, old_phsize, elf_file);</span><br></pre></td></tr></table></figure></p><h2 id="嵌入函数"><a class="anchor" href="#嵌入函数">#</a> 嵌入函数</h2><p>insert 函数定义如下：<br><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Elf32_Ehdr elf_ehdr, <span class="keyword">int</span> old_file, <span class="keyword">int</span> old_entry, <span class="keyword">int</span> old_phsize, <span class="keyword">char</span> *elf_file)</span></span></span><br></pre></td></tr></table></figure></p><p>我们计算原始入口地址的二进制表示，然后为后面嵌入代码做准备，因为嵌入的代码是机器码表示形式。<br><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> old_entry_addr[<span class="number">4</span>];</span><br><span class="line">cal_addr(old_entry, old_entry_addr);</span><br></pre></td></tr></table></figure></p><p>这里，我们用到了 cal_addr 计算地址的函数，该函数源码如下：<br><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal_addr</span><span class="params">(<span class="keyword">int</span> entry, <span class="keyword">int</span> addr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = entry;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        addr[i] = tmp % <span class="number">256</span>; </span><br><span class="line">        tmp /= <span class="number">256</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>嵌入代码用一个 char 类型的数组存放，这里很简单，我们仅仅是嵌入了一个断点调试代码（xchg bx, bx)，然后将原入口地址压栈并返回，继续执行原程序的代码。</p><p><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> inject_code[] = &#123;<span class="number">0x66</span>, <span class="number">0x87</span>, <span class="number">0xdb</span>,              <span class="comment">//xchg bx, bx</span></span><br><span class="line"><span class="number">0x68</span>, old_entry_addr[<span class="number">0</span>], old_entry_addr[<span class="number">1</span>], old_entry_addr[<span class="number">2</span>], old_entry_addr[<span class="number">3</span>],   <span class="comment">//push oldentryaddr</span></span><br><span class="line"><span class="number">0xc3</span>  <span class="comment">//ret</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这里我们先读取可执行文件 old_phsize 大小（之前提到过）的信息放入 buffer 无用缓存区中，然后将嵌入代码注入。这里我们可以将第一个程序头表指向段新增的一页除去嵌入代码的剩余部分全部补 0，当然，我们嵌入的可执行程序很简单，不补 0 也没关系。<br><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">close(old_file);</span><br><span class="line">old_file = open(elf_file, O_RDWR);</span><br><span class="line">read(old_file, &amp;buffer, old_phsize);</span><br><span class="line">write(old_file, inject_code, <span class="keyword">sizeof</span>(inject_code));</span><br><span class="line"><span class="comment">//char tmp[PAGE_SIZE] = &#123;0&#125;;</span></span><br><span class="line"><span class="comment">//memset(tmp, PAGE_SIZE - sizeof(inject_code), 0);</span></span><br><span class="line"><span class="comment">//write(old_file, tmp, PAGE_SIZE - sizeof(inject_code));</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;inject end\n&quot;</span>);</span><br></pre></td></tr></table></figure></p><h2 id="主函数"><a class="anchor" href="#主函数">#</a> 主函数</h2><p>没什么好说的～<br><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error! please input correct command!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    inject(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="完整代码及运行结果"><a class="anchor" href="#完整代码及运行结果">#</a> 完整代码及运行结果</h1><p>我们在一个 shell 中输入命令，来执行嵌入程序并查看结果：</p><p><img data-src="run1.png" alt></p><p>可以看出，嵌入之后的 pwd 可执行文件，会在断点处停止，也就是我们嵌入的断点。</p><p><img data-src="run2.png" alt></p><p>再次按下 c 执行，才会打印出原本的内容。</p><p>完整源码如下：<br><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;elf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;type.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal_addr</span><span class="params">(<span class="keyword">int</span> entry, <span class="keyword">int</span> addr[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inject</span><span class="params">(<span class="keyword">char</span> *elf_file)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Elf32_Ehdr elf_ehdr, <span class="keyword">int</span> old_file, <span class="keyword">int</span> old_entry, <span class="keyword">int</span> old_phsize, <span class="keyword">char</span> *elf_file)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal_addr</span><span class="params">(<span class="keyword">int</span> entry, <span class="keyword">int</span> addr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = entry;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        addr[i] = tmp % <span class="number">256</span>; </span><br><span class="line">        tmp /= <span class="number">256</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inject</span><span class="params">(<span class="keyword">char</span> *elf_file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Start inject code:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> old_entry;   </span><br><span class="line">    <span class="keyword">int</span> old_phsize; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ELF Header Table struct</span></span><br><span class="line">    Elf32_Ehdr elf_ehdr;</span><br><span class="line">    <span class="comment">// Program Header Table struct </span></span><br><span class="line">    Elf32_Phdr elf_phdr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//read elf</span></span><br><span class="line">    <span class="keyword">int</span> old_file = open(elf_file, O_RDWR);</span><br><span class="line">    read(old_file, &amp;elf_ehdr, <span class="keyword">sizeof</span>(elf_ehdr));</span><br><span class="line">    old_entry = elf_ehdr.e_entry;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;old entry: %x\n&quot;</span>, old_entry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//read program head table    </span></span><br><span class="line">    close(old_file);</span><br><span class="line">    old_file = open(elf_file, O_RDWR);</span><br><span class="line">    read(old_file, &amp;buffer , elf_ehdr.e_phoff);</span><br><span class="line">    read(old_file, &amp;elf_phdr, <span class="keyword">sizeof</span>(elf_phdr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update new entry </span></span><br><span class="line">    elf_ehdr.e_entry = elf_phdr.p_vaddr + elf_phdr.p_filesz;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new entry: %x\n&quot;</span>, elf_ehdr.e_entry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//update ELF head</span></span><br><span class="line">    close(old_file);</span><br><span class="line">    old_file = open(elf_file, O_RDWR);</span><br><span class="line">    write(old_file, &amp;elf_ehdr, <span class="keyword">sizeof</span>(elf_ehdr));</span><br><span class="line">    old_phsize = elf_phdr.p_filesz + elf_phdr.p_offset;</span><br><span class="line">    elf_phdr.p_filesz += PAGE_SIZE;</span><br><span class="line">    elf_phdr.p_memsz += PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update program head table</span></span><br><span class="line">    close(old_file);</span><br><span class="line">    old_file = open(elf_file, O_RDWR);</span><br><span class="line">    read(old_file, &amp;buffer, elf_ehdr.e_phoff);</span><br><span class="line">    write(old_file, &amp;elf_phdr, <span class="keyword">sizeof</span>(elf_phdr));</span><br><span class="line">    insert(elf_ehdr, old_file, old_entry, old_phsize, elf_file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Elf32_Ehdr elf_ehdr, <span class="keyword">int</span> old_file, <span class="keyword">int</span> old_entry, <span class="keyword">int</span> old_phsize, <span class="keyword">char</span> *elf_file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_entry_addr[<span class="number">4</span>];</span><br><span class="line">    cal_addr(old_entry, old_entry_addr);</span><br><span class="line">    <span class="keyword">char</span> inject_code[] = &#123;<span class="number">0x66</span>, <span class="number">0x87</span>, <span class="number">0xdb</span>,              <span class="comment">//xchg bx, bx</span></span><br><span class="line">    <span class="number">0x68</span>, old_entry_addr[<span class="number">0</span>], old_entry_addr[<span class="number">1</span>], old_entry_addr[<span class="number">2</span>], old_entry_addr[<span class="number">3</span>],   <span class="comment">//push oldentryaddr</span></span><br><span class="line">    <span class="number">0xc3</span>  <span class="comment">//ret</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    close(old_file);</span><br><span class="line">old_file = open(elf_file, O_RDWR);</span><br><span class="line">    read(old_file, &amp;buffer, old_phsize);</span><br><span class="line">    write(old_file, inject_code, <span class="keyword">sizeof</span>(inject_code));</span><br><span class="line">    <span class="comment">//char tmp[PAGE_SIZE] = &#123;0&#125;;</span></span><br><span class="line">    <span class="comment">//memset(tmp, PAGE_SIZE - sizeof(inject_code), 0);</span></span><br><span class="line">    <span class="comment">//write(old_file, tmp, PAGE_SIZE - sizeof(inject_code));</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;inject end\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error! please input correct command!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    inject(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;elf文件格式&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#elf文件格式&quot;&gt;#&lt;/a&gt; ELF 文件格式&lt;/h1&gt;
&lt;p&gt;&lt;img data-src=&quot;ELF.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;ELF 文件由 4 部分组成，分别是 ELF 头、程序头表、</summary>
      
    
    
    
    <category term="计算机本科课程" scheme="https://osakana373.github.io/categories/Undergraduate-computer-course/"/>
    
    <category term="操作系统" scheme="https://osakana373.github.io/categories/Undergraduate-computer-course/OS/"/>
    
    <category term="Oranges" scheme="https://osakana373.github.io/categories/Undergraduate-computer-course/OS/Oranges/"/>
    
    
    <category term="计算机本科课程" scheme="https://osakana373.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>生命周期</title>
    <link href="https://osakana373.github.io/Front-EndDevelopment/We-chat/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://osakana373.github.io/Front-EndDevelopment/We-chat/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2021-12-03T12:34:21.000Z</published>
    <updated>2021-12-21T12:14:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用生命周期"><a class="anchor" href="#应用生命周期">#</a> 应用生命周期</h1><p>app.js 文件的总体框架：</p><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">APP(&#123;</span><br><span class="line">    <span class="comment">// 包含了各种各样的函数</span></span><br><span class="line">    <span class="comment">//应用第一次启动就会触发的事件，获取用户信息</span></span><br><span class="line">    <span class="function"><span class="title">onLaunch</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 应用被用户看到</span></span><br><span class="line">    <span class="function"><span class="title">onShow</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 对应用的数据或者页面效果重置</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 应用被隐藏</span></span><br><span class="line">    <span class="function"><span class="title">onHide</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 暂停或者清除计时器</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 应用代码发生报错时，会触发</span></span><br><span class="line">    <span class="function"><span class="title">onError</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 在应用发生代码报错的时候，收集用户的错误信息，同构异步请求，将错误的信息发送后台</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 页面找不到会触发 </span></span><br><span class="line">    <span class="function"><span class="title">onPageNotFound</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 应用第一次启动的时候，如找不到入口页面，才会触发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="页面生命周期"><a class="anchor" href="#页面生命周期">#</a> 页面生命周期</h1><p>页面的 js 文件结构如下：相关函数已经按照执行顺序排列</p><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面的初始数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面加载</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">onLoad</span>: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过发送异步请求来初始化页面数据</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面显示</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">onShow</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面初次渲染完成</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">onReady</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面隐藏</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">onHide</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面卸载</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">onUnload</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面相关事件处理函数--监听用户下拉动作</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">onPullDownRefresh</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面上拉触底事件的处理函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">onReachBottom</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 需要让页面出现上下滚动才可</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用户点击右上角分享</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">onShareAppMessage</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面滚动就可以出发</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">onPageScroll</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面的尺寸发生改变的时候触发</span></span><br><span class="line"><span class="comment">   * 指小程序发生横屏竖屏切换的时候触发</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">onResize</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 必须要求当前页面是tabbar页面</span></span><br><span class="line"><span class="comment">   * 点击自己的tab item才会触发</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">onTabItemTap</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      </span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;应用生命周期&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#应用生命周期&quot;&gt;#&lt;/a&gt; 应用生命周期&lt;/h1&gt;
&lt;p&gt;app.js 文件的总体框架：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;figcaptio</summary>
      
    
    
    
    <category term="前端开发" scheme="https://osakana373.github.io/categories/Front-EndDevelopment/"/>
    
    <category term="微信小程序" scheme="https://osakana373.github.io/categories/Front-EndDevelopment/We-chat/"/>
    
    
    <category term="前端开发" scheme="https://osakana373.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>自定义组件</title>
    <link href="https://osakana373.github.io/Front-EndDevelopment/We-chat/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/"/>
    <id>https://osakana373.github.io/Front-EndDevelopment/We-chat/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/</id>
    <published>2021-12-03T01:33:17.000Z</published>
    <updated>2021-12-21T12:14:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组件结构"><a class="anchor" href="#组件结构">#</a> 组件结构</h1><h2 id="wxml文件"><a class="anchor" href="#wxml文件">#</a> wxml 文件</h2><p>对于一个自定义组件，我们考虑的是其模板性，也就是不能够将代码写死。因此我们需要在 view 标签里通过调用 js 文件的 data 数据（初始化数据）来进行数据的访问。wx:for=&quot;&quot;，wx:key=&quot;数组中的某个唯一属性&quot;。同时我们需要在 bindtap 属性定义事件绑定函数<br> <figure class="highlight html"><figcaption><span>wxml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;tabs&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;view class=&quot;tabs_title&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;view class=&quot;title_item&quot;&gt;首页&lt;/view&gt;</span></span><br><span class="line"><span class="comment">        &lt;view class=&quot;title_item&quot;&gt;原创&lt;/view&gt;</span></span><br><span class="line"><span class="comment">        &lt;view class=&quot;title_item&quot;&gt;分类&lt;/view&gt;</span></span><br><span class="line"><span class="comment">        &lt;view class=&quot;title_item&quot;&gt;关于&lt;/view&gt;</span></span><br><span class="line"><span class="comment">    &lt;/view&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;tabs_title&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;tabs&#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;id&quot;</span> <span class="attr">class</span>=<span class="string">&quot;title_item &#123;&#123;item.isActive?&#x27;active&#x27;:&#x27;&#x27;&#125;&#125;&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;handleItemTap&quot;</span> <span class="attr">data-index</span>=<span class="string">&quot;&#123;&#123;index&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;item.name&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;tabs_content&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- slot标签就是一个占位符 插槽 </span></span><br><span class="line"><span class="comment">        等到父组件调用子组件的时候再传递标签过来，</span></span><br><span class="line"><span class="comment">        最终这些被传递的标签就会替换slot插槽的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="wxss文件"><a class="anchor" href="#wxss文件">#</a> wxss 文件</h2><p>定义了一些类的样式，其中 flex 布局需要重点关注，这对于弹性布局非常重要。</p><p><figure class="highlight css"><figcaption><span>wxss</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tabs</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.tabs_title</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10</span>rpx <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.title_item</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.active</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">5</span>rpx solid currentColor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tabs_content</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="js文件"><a class="anchor" href="#js文件">#</a> js 文件</h2><p>我们需要在 data:{} 中定义我们需要预先定义的数据，然后在 methods:{} 中定义事件的绑定函数，这与页面 js 文件的位置不同（见代码和注释）。然后在 view 标签中定义一个被点击的自定义索引：data-index=&quot;&quot;<br><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 组件的属性列表</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 存放的是从父组件中接受的数据</span></span><br><span class="line">  <span class="attr">properties</span>: &#123;</span><br><span class="line">    <span class="comment">// 要接收的数据名称</span></span><br><span class="line">    <span class="attr">tabs</span>: &#123;</span><br><span class="line">      <span class="comment">// type 要接收的数据类型</span></span><br><span class="line">      <span class="attr">type</span>: <span class="built_in">Array</span>,</span><br><span class="line">      <span class="comment">// value 默认值</span></span><br><span class="line">      <span class="attr">value</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 组件的初始数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 组件的方法列表</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 页面.js文件中 存放事件回调函数的时候存放在data同层级下</span></span><br><span class="line"><span class="comment">    2. 组件.js文件中 存放事件回调函数的时候 必须要存放在methods中</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">handleItemTap</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 1 绑定点击事件 需要在methods中绑定</span></span><br><span class="line">      <span class="comment">// 2 获取被点击的索引</span></span><br><span class="line">      <span class="comment">// 3 获取原数组</span></span><br><span class="line">      <span class="comment">/* 4 对数组循环</span></span><br><span class="line"><span class="comment">            1 给每一个循环项选中属性改为false</span></span><br><span class="line"><span class="comment">            2 给当前索引项添加激活选中效果就可以了</span></span><br><span class="line"><span class="comment">         5 点击事件触发的时候，需要触发父组件中的自定义事件，同时传递数据给父组件</span></span><br><span class="line"><span class="comment">            this.triggerEvent(&quot;父组件自定义事件的名称&quot;, 要传递的参数)</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2 获取索引</span></span><br><span class="line">      <span class="keyword">const</span> &#123; index &#125; = e.currentTarget.dataset;</span><br><span class="line">      <span class="comment">// 5 触发父组件中的自定义事件，同时传递参数给父组件</span></span><br><span class="line">      <span class="built_in">this</span>.triggerEvent(<span class="string">&quot;itemChange&quot;</span>, &#123; index &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="json文件"><a class="anchor" href="#json文件">#</a> json 文件</h2><p>默认即可</p><p><figure class="highlight json"><figcaption><span>json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;component&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;usingComponents&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="页面组件的父组件结构"><a class="anchor" href="#页面组件的父组件结构">#</a> 页面（组件的父组件）结构</h1><h2 id="wxml文件-2"><a class="anchor" href="#wxml文件-2">#</a> wxml 文件</h2><p><figure class="highlight html"><figcaption><span>wxml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 父组件（页面）向子组件传递数据通过标签属性的方式来传递 </span></span><br><span class="line"><span class="comment">        1.1 在子组件上进行接收 </span></span><br><span class="line"><span class="comment">     2. 子向父传递数据，通过事件的方式传递 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Tabs</span> <span class="attr">tabs</span>=<span class="string">&quot;&#123;&#123;tabs&#125;&#125;&quot;</span> <span class="attr">binditemChange</span>=<span class="string">&quot;handleItemChange&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;tabs[0].isActive&#125;&#125;&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:elif</span>=<span class="string">&quot;&#123;&#123;tabs[1].isActive&#125;&#125;&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:elif</span>=<span class="string">&quot;&#123;&#123;tabs[2].isActive&#125;&#125;&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:elif</span>=<span class="string">&quot;&#123;&#123;tabs[3].isActive&#125;&#125;&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Tabs</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="js文件-2"><a class="anchor" href="#js文件-2">#</a> js 文件</h2><p><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面的初始数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">tabs</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;首页&quot;</span>,</span><br><span class="line">        <span class="attr">isActive</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;原创&quot;</span>,</span><br><span class="line">        <span class="attr">isActive</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;分类&quot;</span>,</span><br><span class="line">        <span class="attr">isActive</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;关于&quot;</span>,</span><br><span class="line">        <span class="attr">isActive</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//自定义事件 用来接收子组件传递的数据</span></span><br><span class="line">  <span class="function"><span class="title">handleItemChange</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 接收传递过来的参数</span></span><br><span class="line">    <span class="keyword">const</span> &#123; index &#125; = e.detail;</span><br><span class="line">    <span class="comment">// 解构：对复杂类型进行解构时，复制了一份变量的引用而已</span></span><br><span class="line">    <span class="comment">// let tabs = this.data.tabs</span></span><br><span class="line">    <span class="comment">// 最严谨的做法是重新拷贝一份数组，再对数组的备份进行处理</span></span><br><span class="line">    <span class="comment">// let tabs=JSON.parse&#123;JSON.stringify(this.data.tabs)&#125;;</span></span><br><span class="line">    <span class="keyword">let</span> &#123; tabs &#125; = <span class="built_in">this</span>.data;</span><br><span class="line">    <span class="comment">// [].forEach 遍历数组 遍历数组时修改了v，也会导致原数组被修改</span></span><br><span class="line">    tabs.forEach(<span class="function">(<span class="params">v, i</span>) =&gt;</span> i === index ? v.isActive = <span class="literal">true</span> : v.isActive = <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 会将tabs传给自己的data中</span></span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      tabs</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="json文件-2"><a class="anchor" href="#json文件-2">#</a> json 文件</h2><p>我们需要在 usingComponents 中找到我们自定义组件的相对路径。注意，由于组件包含了 wxml,wxss,js,json 四个同名文件，因此我们在最后的 Tabs 后不需要添加后缀名。<br><figure class="highlight json"><figcaption><span>json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;usingComponents&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Tabs&quot;</span>:<span class="string">&quot;../../components/Tabs/Tabs&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="过程分析"><a class="anchor" href="#过程分析">#</a> 过程分析</h1><ol><li>首先我们在 Tabs 组件 wxml 文件中定义一个模板，其中包含了 view 标签和所属的 class 类，用于对应组件 wxss 文件中定义的布局</li><li>组件的事件回调函数需要定义在 methods 中，在组件 wxml 文件标签中，有这样两个属性：<ol><li>bindtap：用于指定点击事件的触发函数名 (handleItemTap)</li><li>data-index：用于指定数据的索引</li></ol></li><li>进入组件的 js 文件中，在 methods 中绑定点击事件 handleItemTap (){}，在该事件函数中我们首先获取索引，然后触发父组件的自定义事件，同时传递参数给父组件 (this.triggerEvent (&quot;itemChange&quot;, { index }))。这里并没有直接对原数组进行修改，因为在组件中对父页面的 data 数据进行修改，是无效的</li><li>在页面 wxml 文件的 Tabs 自定义组件标签中绑定单击响应函数 (binditemChange=&quot;handleItemChange&quot;)，然后在页面 js 文件中定义这个函数（与 data 平行，这与组件中函数位置有所不同）。</li></ol><h3 id="需要注意的地方"><a class="anchor" href="#需要注意的地方">#</a> 需要注意的地方</h3><ol><li>组件接收父组件的数据位置在 properties 中，需要指定数据名，数据类型和默认 value</li><li>我们没有将主要的处理步骤放在组件的事件回调函数中，是因为 setData 的时候又将修改过的 tabs 存进了自己的 data 区，也就是说，在 properties 有一个 tabs 数组，在自己的 data 区又有一个 tabs 数组，这会出问题</li><li>组件 wxml 文件中 slot 标签的作用：一个占位符 插槽，等到父组件调用子组件的时候再传递标签过来，最终这些被传递的标签就会替换 slot 插槽的位置，也就是我们样例中页面 wxml 文件的 wx:if 语句选择的那个标签</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组件结构&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#组件结构&quot;&gt;#&lt;/a&gt; 组件结构&lt;/h1&gt;
&lt;h2 id=&quot;wxml文件&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#wxml文件&quot;&gt;#&lt;/a&gt; wxml 文件&lt;/h2&gt;
&lt;p&gt;对于一个自定义组</summary>
      
    
    
    
    <category term="前端开发" scheme="https://osakana373.github.io/categories/Front-EndDevelopment/"/>
    
    <category term="微信小程序" scheme="https://osakana373.github.io/categories/Front-EndDevelopment/We-chat/"/>
    
    
    <category term="前端开发" scheme="https://osakana373.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>单选框和复选框</title>
    <link href="https://osakana373.github.io/Front-EndDevelopment/We-chat/%E5%8D%95%E9%80%89%E6%A1%86%E5%92%8C%E5%A4%8D%E9%80%89%E6%A1%86/"/>
    <id>https://osakana373.github.io/Front-EndDevelopment/We-chat/%E5%8D%95%E9%80%89%E6%A1%86%E5%92%8C%E5%A4%8D%E9%80%89%E6%A1%86/</id>
    <published>2021-12-03T01:21:17.000Z</published>
    <updated>2021-12-21T12:14:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="radio-单选框"><a class="anchor" href="#radio-单选框">#</a> radio 单选框</h1><ol><li>radio 标签必须要和父元素 radio-group 一起使用</li><li>value 选中的单选框的值</li><li>需要给 radio-group 绑定 change 事件</li></ol><p><figure class="highlight html"><figcaption><span>wxml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">radio-group</span> <span class="attr">bindchange</span>=<span class="string">&quot;事件名&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">radio</span> <span class="attr">color</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">radio</span> <span class="attr">color</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">radio-group</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="checkbox-复选框"><a class="anchor" href="#checkbox-复选框">#</a> checkbox 复选框</h1><p><figure class="highlight html"><figcaption><span>wxml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">checkbox-group</span> <span class="attr">bindchange</span>=<span class="string">&quot;事件名&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">checkbox</span> <span class="attr">color</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;&#125;&#125;&quot;</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;&#125;&#125;&quot;</span> <span class="attr">wx:key:</span>&quot;&#123;&#123;&#125;&#125;&quot;&gt;</span>xxx<span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">checkbox</span> <span class="attr">color</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;&#125;&#125;&quot;</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;&#125;&#125;&quot;</span> <span class="attr">wx:key:</span>&quot;&#123;&#123;&#125;&#125;&quot;&gt;</span>xxx<span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">checkbox-group</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;radio-单选框&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#radio-单选框&quot;&gt;#&lt;/a&gt; radio 单选框&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;radio 标签必须要和父元素 radio-group 一起使用&lt;/li&gt;
&lt;li&gt;value 选中的单选框的</summary>
      
    
    
    
    <category term="前端开发" scheme="https://osakana373.github.io/categories/Front-EndDevelopment/"/>
    
    <category term="微信小程序" scheme="https://osakana373.github.io/categories/Front-EndDevelopment/We-chat/"/>
    
    
    <category term="前端开发" scheme="https://osakana373.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>button按钮</title>
    <link href="https://osakana373.github.io/Front-EndDevelopment/We-chat/button%E6%8C%89%E9%92%AE/"/>
    <id>https://osakana373.github.io/Front-EndDevelopment/We-chat/button%E6%8C%89%E9%92%AE/</id>
    <published>2021-11-30T14:57:00.000Z</published>
    <updated>2021-12-21T12:14:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="外观属性"><a class="anchor" href="#外观属性">#</a> 外观属性</h1><ol><li>样式：&lt;button&gt;xxx&lt;/button&gt;</li><li>size 控制按钮的大小<ol><li>default 默认</li><li>mini 小尺寸</li></ol></li><li>type 用来控制按钮的颜色<ol><li>default 灰色</li><li>primary 绿色</li><li>warn 红色</li></ol></li><li>plain 红色是否镂空，背景色透明</li><li>loading 是否有加载图标</li></ol><h1 id="开放能力open-type"><a class="anchor" href="#开放能力open-type">#</a> 开放能力 open-type</h1><ol><li>contact 直接打开客服对话功能，需要微信小程序的后台配置<ol><li>只能够通过真机调试来打开</li></ol></li><li>share 转发当前的小程序到微信朋友中 不能把小程序分享到朋友圈中</li><li>getPhoneNumber 获取当前用户的手机号码信息<ol><li>绑定一个时间 bindgetphonenumber</li><li>在事件的回调函数中通过参数来获取信息</li><li>获取到的信息已经经过加密，需要用户自己搭建小程序的后台服务器，在后台服务器中进行解析手机号码，返回到小程序中，就可看到信息</li></ol></li><li>getUserInfo 获取当前用户的个人信息<ol><li>使用方法类似获取手机号码</li><li>可直接获取，不存在加密的字段</li></ol></li><li>launchAPP 在小程序当中直接打开 app<ol><li>需要先在 app 中通过 app 的某个链接打开小程序</li><li>在小程序中通过这个功能重新打开 app</li></ol></li><li>openSetting 打开小程序的内置授权页<ol><li>授权页面中只会出现用户曾经点击过的权限</li></ol></li><li>feedback 打开小程序内置的意见反馈页面<ol><li>只能够通过真机调试来打开</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;外观属性&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#外观属性&quot;&gt;#&lt;/a&gt; 外观属性&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;样式：&amp;lt;button&amp;gt;xxx&amp;lt;/button&amp;gt;&lt;/li&gt;
&lt;li&gt;size 控制按钮的大小
&lt;ol&gt;
&lt;li&gt;def</summary>
      
    
    
    
    <category term="前端开发" scheme="https://osakana373.github.io/categories/Front-EndDevelopment/"/>
    
    <category term="微信小程序" scheme="https://osakana373.github.io/categories/Front-EndDevelopment/We-chat/"/>
    
    
    <category term="前端开发" scheme="https://osakana373.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>rich-text富文本标签</title>
    <link href="https://osakana373.github.io/Front-EndDevelopment/We-chat/rich-text%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE/"/>
    <id>https://osakana373.github.io/Front-EndDevelopment/We-chat/rich-text%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE/</id>
    <published>2021-11-30T14:39:17.000Z</published>
    <updated>2021-12-21T12:14:40.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>nodes 属性来实现<ol><li>接受标签字符串 最常用<br>属性名:'&lt;div&gt;'</li><li>对象数组<br> <figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">html:[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;div&quot;</span>,</span><br><span class="line">        <span class="attr">attrs</span>:&#123;</span><br><span class="line">            <span class="attr">class</span>:<span class="string">&quot;my_div&quot;</span>,</span><br><span class="line">            <span class="attr">style</span>:<span class="string">&quot;color:red;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">children</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">name</span>:<span class="string">&quot;p&quot;</span>,</span><br><span class="line">                <span class="attr">attrs</span>:&#123;&#125;,</span><br><span class="line">                <span class="attr">children</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                     <span class="attr">type</span>:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">                     <span class="attr">text</span>:<span class="string">&quot;hello&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;nodes 属性来实现
&lt;ol&gt;
&lt;li&gt;接受标签字符串 最常用&lt;br&gt;
属性名:&#39;&amp;lt;div&amp;gt;&#39;&lt;/li&gt;
&lt;li&gt;对象数组&lt;br&gt;
 &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;figcaption&gt;&lt;span&gt;ja</summary>
      
    
    
    
    <category term="前端开发" scheme="https://osakana373.github.io/categories/Front-EndDevelopment/"/>
    
    <category term="微信小程序" scheme="https://osakana373.github.io/categories/Front-EndDevelopment/We-chat/"/>
    
    
    <category term="前端开发" scheme="https://osakana373.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>navigator导航标签</title>
    <link href="https://osakana373.github.io/Front-EndDevelopment/We-chat/navigator%E5%AF%BC%E8%88%AA%E6%A0%87%E7%AD%BE/"/>
    <id>https://osakana373.github.io/Front-EndDevelopment/We-chat/navigator%E5%AF%BC%E8%88%AA%E6%A0%87%E7%AD%BE/</id>
    <published>2021-11-30T14:21:27.000Z</published>
    <updated>2021-12-21T12:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>样式：&lt;navigator url=&quot;/xxx&quot; open-type=&quot;xxx&quot;&gt; xxx &lt;/navigator&gt;</li><li>块级元素，默认会换行，可以加上宽度和高度</li><li>url 要跳转的页面路径，绝对路径和相对路径均可</li><li>target 要跳转到当前小程序还是其他的小程序<br> self 默认值；nimiProgram 其他的小程序页面</li><li>open-type 跳转的方式<ol><li>navigate 默认值，保留当前页面，跳转到应用内的某个页面，但是不能跳转到 tabbar 页面</li><li>redirect 关闭当前页面（不保存，没有返回按钮），跳转到应用内的某个页面，但是不允许跳转到 tabbar 页面</li><li>switchTab 跳转到 tabbar 页面，并关闭其他所有非 tabbar 页面</li><li>reLaunch 关闭所有页面，打开到应用内的某个页面</li><li>exit 退出小程序，targer=&quot;miniProgram&quot; 时生效</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;样式：&amp;lt;navigator url=&amp;quot;/xxx&amp;quot; open-type=&amp;quot;xxx&amp;quot;&amp;gt; xxx &amp;lt;/navigator&amp;gt;&lt;/li&gt;
&lt;li&gt;块级元素，默认会换行，可以加上宽度和高度&lt;/li&gt;
&lt;li&gt;u</summary>
      
    
    
    
    <category term="前端开发" scheme="https://osakana373.github.io/categories/Front-EndDevelopment/"/>
    
    <category term="微信小程序" scheme="https://osakana373.github.io/categories/Front-EndDevelopment/We-chat/"/>
    
    
    <category term="前端开发" scheme="https://osakana373.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序之swiper轮播图</title>
    <link href="https://osakana373.github.io/Front-EndDevelopment/We-chat/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8Bswiper%E8%BD%AE%E6%92%AD%E5%9B%BE/"/>
    <id>https://osakana373.github.io/Front-EndDevelopment/We-chat/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8Bswiper%E8%BD%AE%E6%92%AD%E5%9B%BE/</id>
    <published>2021-11-30T14:08:37.000Z</published>
    <updated>2021-12-21T12:14:24.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>轮播图外层容器 swiper</li><li>每一个轮播项 swiper-item</li><li>swiper 标签 存在默认样式<ol><li>width 100%</li><li>height 150px image 存在默认宽度和高度 320*240</li><li>swiper 高度无法实现由内容撑开</li></ol></li><li>先找出来原图的宽度和高度，等比例给 swiper 定宽高，可以在 CSS 里面用 calc () 函数计算</li><li>autoplay 自动轮播</li><li>interval 修改轮播时间</li><li>circular 衔接轮播</li><li>indicator-dots 显示指示器（有小圆点）</li><li>indicator-color 指示器的未选中的颜色</li><li>indicator-active-color 指示器的选中的颜色</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;轮播图外层容器 swiper&lt;/li&gt;
&lt;li&gt;每一个轮播项 swiper-item&lt;/li&gt;
&lt;li&gt;swiper 标签 存在默认样式
&lt;ol&gt;
&lt;li&gt;width 100%&lt;/li&gt;
&lt;li&gt;height 150px image 存在默认宽度和高度 320*</summary>
      
    
    
    
    <category term="前端开发" scheme="https://osakana373.github.io/categories/Front-EndDevelopment/"/>
    
    <category term="微信小程序" scheme="https://osakana373.github.io/categories/Front-EndDevelopment/We-chat/"/>
    
    
    <category term="前端开发" scheme="https://osakana373.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之内存管理</title>
    <link href="https://osakana373.github.io/Undergraduate-computer-course/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://osakana373.github.io/Undergraduate-computer-course/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-11-29T06:44:30.000Z</published>
    <updated>2021-12-13T17:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fork"><a class="anchor" href="#fork">#</a> fork</h1><p>一个新的进程需要的要素：</p><ul><li>自己的代码，数据和堆栈；</li><li>在 proc_table [] 中占用一个位置；</li><li>在 GDT 中占用一个位置，用以存放进程对应的 LDT 描述符。</li></ul><h2 id="fork概念"><a class="anchor" href="#fork概念">#</a> fork 概念</h2><p>系统调用 fork () 用来生成一个子进程。每个进程有唯一的 pid，如果调用 fork () 前后 pid 一致，说明进程为父进程，反之为子进程。</p><p><img data-src="process_associate.png" alt="一个进程涉及的所有数据结构及相互联系"></p><h2 id="准备工作"><a class="anchor" href="#准备工作">#</a> 准备工作</h2><p>fork 前我们可以提前做好准备的事情：</p><ul><li>在 proc_table [] 中预留出一些空项，供新进程使用；</li><li>将 proc_table [] 中的每一个进程表项中的 ldt_sel 项都设定好（关系②)；</li><li>将进程所需的 GDT 表项都初始化好（关系①）。</li></ul><p>书中将整个内核占用的内存当做 Init 的内存范围。</p><h2 id="fork库函数"><a class="anchor" href="#fork库函数">#</a> fork () 库函数</h2><p><img data-src="fork.png" alt="fork()"></p><h2 id="mm内存管理"><a class="anchor" href="#mm内存管理">#</a> MM（内存管理）</h2><pre><code><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PUBLIC <span class="keyword">int</span> <span class="title">do_fork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* find a free slot in proc_table */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> proc_table;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_TASKS + NR_PROCS; i++,p++)</span><br><span class="line"><span class="keyword">if</span> (p-&gt;p_flags == FREE_SLOT)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> child_pid = i;</span><br><span class="line">assert(p == &amp;proc_table[child_pid]);</span><br><span class="line">assert(child_pid &gt;= NR_TASKS + NR_NATIVE_PROCS);</span><br><span class="line"><span class="keyword">if</span> (i == NR_TASKS + NR_PROCS) <span class="comment">/* no free slot */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">assert(i &lt; NR_TASKS + NR_PROCS);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* duplicate the process table */</span></span><br><span class="line"><span class="keyword">int</span> pid = mm_msg.source;</span><br><span class="line">u16 child_ldt_sel = p-&gt;ldt_sel;</span><br><span class="line">*p = proc_table[pid];</span><br><span class="line">p-&gt;ldt_sel = child_ldt_sel;</span><br><span class="line">p-&gt;p_parent = pid;</span><br><span class="line"><span class="built_in">sprintf</span>(p-&gt;name, <span class="string">&quot;%s_%d&quot;</span>, proc_table[pid].name, child_pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* duplicate the process: T, D &amp; S */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">descriptor</span> * <span class="title">ppd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Text segment */</span></span><br><span class="line">ppd = &amp;proc_table[pid].ldts[INDEX_LDT_C];</span><br><span class="line"><span class="comment">/* base of T-seg, in bytes */</span></span><br><span class="line"><span class="keyword">int</span> caller_T_base  = reassembly(ppd-&gt;base_high, <span class="number">24</span>,</span><br><span class="line">ppd-&gt;base_mid,  <span class="number">16</span>,</span><br><span class="line">ppd-&gt;base_low);</span><br><span class="line"><span class="comment">/* limit of T-seg, in 1 or 4096 bytes,</span></span><br><span class="line"><span class="comment">depending on the G bit of descriptor */</span></span><br><span class="line"><span class="keyword">int</span> caller_T_limit = reassembly(<span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">(ppd-&gt;limit_high_attr2 &amp; <span class="number">0xF</span>), <span class="number">16</span>,</span><br><span class="line">ppd-&gt;limit_low);</span><br><span class="line"><span class="comment">/* size of T-seg, in bytes */</span></span><br><span class="line"><span class="keyword">int</span> caller_T_size  = ((caller_T_limit + <span class="number">1</span>) *</span><br><span class="line">((ppd-&gt;limit_high_attr2 &amp; (DA_LIMIT_4K &gt;&gt; <span class="number">8</span>)) ?</span><br><span class="line"><span class="number">4096</span> : <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Data &amp; Stack segments */</span></span><br><span class="line">ppd = &amp;proc_table[pid].ldts[INDEX_LDT_RW];</span><br><span class="line"><span class="comment">/* base of D&amp;S-seg, in bytes */</span></span><br><span class="line"><span class="keyword">int</span> caller_D_S_base  = reassembly(ppd-&gt;base_high, <span class="number">24</span>,</span><br><span class="line">ppd-&gt;base_mid,  <span class="number">16</span>,</span><br><span class="line">ppd-&gt;base_low);</span><br><span class="line"><span class="comment">/* limit of D&amp;S-seg, in 1 or 4096 bytes,</span></span><br><span class="line"><span class="comment">depending on the G bit of descriptor */</span></span><br><span class="line"><span class="keyword">int</span> caller_D_S_limit = reassembly((ppd-&gt;limit_high_attr2 &amp; <span class="number">0xF</span>), <span class="number">16</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">ppd-&gt;limit_low);</span><br><span class="line"><span class="comment">/* size of D&amp;S-seg, in bytes */</span></span><br><span class="line"><span class="keyword">int</span> caller_D_S_size  = ((caller_T_limit + <span class="number">1</span>) *</span><br><span class="line">((ppd-&gt;limit_high_attr2 &amp; (DA_LIMIT_4K &gt;&gt; <span class="number">8</span>)) ?</span><br><span class="line"><span class="number">4096</span> : <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* we don&#x27;t separate T, D &amp; S segments, so we have: */</span></span><br><span class="line">assert((caller_T_base  == caller_D_S_base ) &amp;&amp;</span><br><span class="line">(caller_T_limit == caller_D_S_limit) &amp;&amp;</span><br><span class="line">(caller_T_size  == caller_D_S_size ));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* base of child proc, T, D &amp; S segments share the same space,</span></span><br><span class="line"><span class="comment">so we allocate memory just once */</span></span><br><span class="line"><span class="keyword">int</span> child_base = alloc_mem(child_pid, caller_T_size);</span><br><span class="line"><span class="comment">/* int child_limit = caller_T_limit; */</span></span><br><span class="line">printl(<span class="string">&quot;&#123;MM&#125; 0x%x &lt;- 0x%x (0x%x bytes)\n&quot;</span>,</span><br><span class="line">child_base, caller_T_base, caller_T_size);</span><br><span class="line"><span class="comment">/* child is a copy of the parent */</span></span><br><span class="line">phys_copy((<span class="keyword">void</span>*)child_base, (<span class="keyword">void</span>*)caller_T_base, caller_T_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* child&#x27;s LDT */</span></span><br><span class="line">init_desc(&amp;p-&gt;ldts[INDEX_LDT_C],</span><br><span class="line">child_base,</span><br><span class="line">(PROC_IMAGE_SIZE_DEFAULT - <span class="number">1</span>) &gt;&gt; LIMIT_4K_SHIFT,</span><br><span class="line">DA_LIMIT_4K | DA_32 | DA_C | PRIVILEGE_USER &lt;&lt; <span class="number">5</span>);</span><br><span class="line">init_desc(&amp;p-&gt;ldts[INDEX_LDT_RW],</span><br><span class="line">child_base,</span><br><span class="line">(PROC_IMAGE_SIZE_DEFAULT - <span class="number">1</span>) &gt;&gt; LIMIT_4K_SHIFT,</span><br><span class="line">DA_LIMIT_4K | DA_32 | DA_DRW | PRIVILEGE_USER &lt;&lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tell FS, see fs_fork() */</span></span><br><span class="line">MESSAGE msg2fs;</span><br><span class="line">msg2fs.type = FORK;</span><br><span class="line">msg2fs.PID = child_pid;</span><br><span class="line">send_recv(BOTH, TASK_FS, &amp;msg2fs);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* child PID will be returned to the parent proc */</span></span><br><span class="line">mm_msg.PID = child_pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* birth of the child */</span></span><br><span class="line">MESSAGE m;</span><br><span class="line">m.type = SYSCALL_RET;</span><br><span class="line">m.RETVAL = <span class="number">0</span>;</span><br><span class="line">m.PID = <span class="number">0</span>;</span><br><span class="line">send_recv(SEND, child_pid, &amp;m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ol><li>分配进程表。从数组 proc_table [] 中寻找一个空项，用于存放子进程的进程表。然后将父进程的进程表原原本本赋给子进程。</li><li>分配内存。读取 LDT 来得到父进程的内存占用情况。注意，我们不区分代码、数据和堆栈，即三个段指向相同的地址空间。phys_copy () 函数将父进程的内存空间完整地赋值一份给新分配的空间。由于内存空间不同，需要更新子进程的 LDT。</li><li>通知 FS，进行父子进程间的文件共享。</li><li>给子进程发一个消息，解除阻塞，并将 0 作为返回值传递给子进程，让子进程知道自己的身份。对于父进程，MM 的主消息循环会发送消息给它。</li></ol><p>注意：我们需要特别关注对内存分配（默认一个格子 1MB）和文件描述符的处理（FS 用于增加两个计数器）。</p><h3 id="内存分配"><a class="anchor" href="#内存分配">#</a> 内存分配</h3><p>内存分配采用划定格子的方案，每个格子大小固定。有新的进程需要内存，就给一个格子，且该进程在整个生命周期中，只能使用这个格子的内存。</p><p>首先定义内存分配相关的宏：<br><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">#<span class="meta-keyword">define</span>PROCS_BASE0xA00000 <span class="comment">/* 10 MB */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>PROC_IMAGE_SIZE_DEFAULT0x100000 <span class="comment">/*  1 MB */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>PROC_ORIGIN_STACK0x400    <span class="comment">/*  1 KB */</span></span></span><br></pre></td></tr></table></figure></p><p>分配内存函数：<br><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PUBLIC <span class="keyword">int</span> <span class="title">alloc_mem</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> memsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pid &gt;= (NR_TASKS + NR_NATIVE_PROCS));</span><br><span class="line"><span class="keyword">if</span> (memsize &gt; PROC_IMAGE_SIZE_DEFAULT) &#123;</span><br><span class="line">panic(<span class="string">&quot;unsupported memory request: %d. &quot;</span></span><br><span class="line"><span class="string">&quot;(should be less than %d)&quot;</span>,</span><br><span class="line">memsize,</span><br><span class="line">PROC_IMAGE_SIZE_DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> base = PROCS_BASE +</span><br><span class="line">(pid - (NR_TASKS + NR_NATIVE_PROCS)) * PROC_IMAGE_SIZE_DEFAULT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (base + memsize &gt;= memory_size)</span><br><span class="line">panic(<span class="string">&quot;memory allocation failed. pid:%d&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="对文件描述符的处理"><a class="anchor" href="#对文件描述符的处理">#</a> 对文件描述符的处理</h3><p>fork 一个子进程需要 FS 来协助，FS 主要是增加两个计数器：</p><ul><li>隶属于 inode 结构的 i_cnt 计数器：只要有进程使用这个 inode，其 i_cnt 就加 1；</li><li>属于 file_desc 结构的 fd_cnt：假设进程 P 生成进程 C，那么 P,C 共享使用 f_desc_table [] 中的同一个 file_desc 结构，这时 fd_cnt 为 2。退出一个进程就自减。当 fd_cnt 自减为 0，系统会将 fd_inode 赋值为 0，这样改 f_desc_table [] 条目又可以被使用了。</li></ul><h1 id="exit和wait"><a class="anchor" href="#exit和wait">#</a> exit 和 wait</h1><p>exit ()：进程退出。<br>父进程得到返回值，就是执行一个 wait () 挂起，等子进程退出时，wait () 调用方结束，并且父进程因此得到返回值。</p><h1 id="exec"><a class="anchor" href="#exec">#</a> exec</h1><p>exec: 将当前的进程映像替换成另一个，也就是说，我们可以从硬盘上读取另一个可执行的文件，用它替换掉刚刚被 fork 出来的子进程。</p><h2 id="简单的shell"><a class="anchor" href="#简单的shell">#</a> 简单的 shell</h2><p><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shabby_shell</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * tty_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd_stdin  = open(tty_name, O_RDWR);</span><br><span class="line">assert(fd_stdin  == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> fd_stdout = open(tty_name, O_RDWR);</span><br><span class="line">assert(fd_stdout == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> rdbuf[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;$ &quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> r = read(<span class="number">0</span>, rdbuf, <span class="number">70</span>);</span><br><span class="line">rdbuf[r] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> argc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> * argv[PROC_ORIGIN_STACK];</span><br><span class="line"><span class="keyword">char</span> * p = rdbuf;</span><br><span class="line"><span class="keyword">char</span> * s;</span><br><span class="line"><span class="keyword">int</span> word = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">ch = *p;</span><br><span class="line"><span class="keyword">if</span> (*p != <span class="string">&#x27; &#x27;</span> &amp;&amp; *p != <span class="number">0</span> &amp;&amp; !word) &#123;</span><br><span class="line">s = p;</span><br><span class="line">word = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*p == <span class="string">&#x27; &#x27;</span> || *p == <span class="number">0</span>) &amp;&amp; word) &#123;</span><br><span class="line">word = <span class="number">0</span>;</span><br><span class="line">argv[argc++] = s;</span><br><span class="line">*p = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">p++;</span><br><span class="line">&#125; <span class="keyword">while</span>(ch);</span><br><span class="line">argv[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd = open(argv[<span class="number">0</span>], O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (rdbuf[<span class="number">0</span>]) &#123;</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;&#123;&quot;</span>, <span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, rdbuf, r);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;&#125;\n&quot;</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid != <span class="number">0</span>) &#123; <span class="comment">/* parent */</span></span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line">wait(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">/* child */</span></span><br><span class="line">execv(argv[<span class="number">0</span>], argv);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(<span class="number">1</span>);</span><br><span class="line">close(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight c"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd_stdin  = open(<span class="string">&quot;/dev_tty0&quot;</span>, O_RDWR);</span><br><span class="line">assert(fd_stdin  == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> fd_stdout = open(<span class="string">&quot;/dev_tty0&quot;</span>, O_RDWR);</span><br><span class="line">assert(fd_stdout == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Init() is running ...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract `cmd.tar&#x27; */</span></span><br><span class="line">untar(<span class="string">&quot;/cmd.tar&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * tty_list[] = &#123;<span class="string">&quot;/dev_tty1&quot;</span>, <span class="string">&quot;/dev_tty2&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(tty_list) / <span class="keyword">sizeof</span>(tty_list[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid != <span class="number">0</span>) &#123; <span class="comment">/* parent process */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[parent is running, child pid:%d]\n&quot;</span>, pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">/* child process */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[child is running, pid:%d]\n&quot;</span>, getpid());</span><br><span class="line">close(fd_stdin);</span><br><span class="line">close(fd_stdout);</span><br><span class="line"></span><br><span class="line">shabby_shell(tty_list[i]);</span><br><span class="line">assert(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">int</span> child = wait(&amp;s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child (%d) exited with status: %d.\n&quot;</span>, child, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;fork&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#fork&quot;&gt;#&lt;/a&gt; fork&lt;/h1&gt;
&lt;p&gt;一个新的进程需要的要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自己的代码，数据和堆栈；&lt;/li&gt;
&lt;li&gt;在 proc_table [] 中占用一个位置；&lt;/li</summary>
      
    
    
    
    <category term="计算机本科课程" scheme="https://osakana373.github.io/categories/Undergraduate-computer-course/"/>
    
    <category term="操作系统" scheme="https://osakana373.github.io/categories/Undergraduate-computer-course/OS/"/>
    
    <category term="Oranges" scheme="https://osakana373.github.io/categories/Undergraduate-computer-course/OS/Oranges/"/>
    
    
    <category term="计算机本科课程" scheme="https://osakana373.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>2021年11月29日</title>
    <link href="https://osakana373.github.io/2021%E5%B9%B411%E6%9C%8829%E6%97%A5/"/>
    <id>https://osakana373.github.io/2021%E5%B9%B411%E6%9C%8829%E6%97%A5/</id>
    <published>2021-11-28T16:14:49.000Z</published>
    <updated>2021-11-28T16:41:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>这周爱上了安田レイ的アシンメトリー，很有感染力，单曲循环～</p><p>从十一月下旬开始，课程作业环环相扣，简直不能喘过气来，各种各样的事情，总感觉时间过得很快，恨不得一天得有 48 小时才满意。又想起了去年这个时候，我还在努力地背日语单词，准备 JLPT，那个时候的魄力，居然能够忍住将近两个月不玩游戏，在现在的我看来真是让人大吃一惊。</p><p>昨天又跟 npy 吵架了，也说不上吵，在我看来，就是她有点无理取闹吧。跟去年这个时候简直如出一辙，我在认真备考，她总是想要以 “天天都忙，不理她” 的理由找茬，本来在写实验报告或者写代码的时候被打扰，就是一件非常扰乱思绪的事情，总不能每次都秒回，但我看到消息总会回的吧。这次也是，还解除 QQ 情侣关系什么的，虽说这不是个什么大事，但总觉得内心烦躁，在赶实验报告之际让我再次感受痛苦。哎，实验报告又拖延了，没心情写下去了。</p><p>看着这个长不大的磨人的小妖精，再次对アシンメトリー中的歌词很有感触啊。<br>誰より好きだから　　<br>誰よりもきらいになる　　<br>私の気持ちを　　<br>どうしてわからないんだろう　　<br>きみとはぜんぜんちがう　　<br>生き物じゃ割り切れない　　<br>心の答え合わせは　　<br>やめてありのままに　恋をしよう</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这周爱上了安田レイ的アシンメトリー，很有感染力，单曲循环～&lt;/p&gt;
&lt;p&gt;从十一月下旬开始，课程作业环环相扣，简直不能喘过气来，各种各样的事情，总感觉时间过得很快，恨不得一天得有 48 小时才满意。又想起了去年这个时候，我还在努力地背日语单词，准备 JLPT，那个时候的魄力</summary>
      
    
    
    
    <category term="生活随笔" scheme="https://osakana373.github.io/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="日常" scheme="https://osakana373.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
</feed>
